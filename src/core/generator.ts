import path from 'path';
import { readFile, fileExists, writeFile, ensureDir } from '../utils/file-system.js';
import type { ProjectConfig } from '../types.js';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Resolve templates directory (handles both dev and production)
function getTemplatesDir(): string {
  // In production (dist/), templates are at package root
  // In development (src/), templates are at package root
  // Both resolve to same location
  return path.join(__dirname, '..', '..', 'templates');
}

// Helper to read core template files (AGENT_AUTOMATION, DOCUMENTATION_RULES, QUALITY_ENFORCEMENT, RULEBOOK)
async function generateCoreRules(name: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'core');
  const templatePath = path.join(templatesDir, `${name.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  return `<!-- ${name.toUpperCase()}:START -->\n# ${name.charAt(0).toUpperCase() + name.slice(1)} Rules\n\nCore rules for ${name}.\n<!-- ${name.toUpperCase()}:END -->\n`;
}

export async function generateAgentsContent(config: ProjectConfig): Promise<string> {
  const sections: string[] = [];

  // Header comment
  sections.push('<!-- RULEBOOK:START -->');
  sections.push('# Project Rules');
  sections.push('');
  sections.push('Generated by @hivellm/rulebook');
  sections.push(`Generated at: ${new Date().toISOString()}`);
  sections.push('');

  const rulebookDir = config.rulebookDir || '.rulebook';

  // RULEBOOK.md has HIGHEST PRECEDENCE - must be first and most prominent
  sections.push('## ‚ö†Ô∏è CRITICAL: Task Management Rules (HIGHEST PRECEDENCE)');
  sections.push('');
  sections.push('**MANDATORY**: All task creation MUST follow Rulebook task management system.');
  sections.push('');
  sections.push(
    `**üìã ALWAYS reference \`/${rulebookDir}/specs/RULEBOOK.md\` FIRST before creating any tasks.**`
  );
  sections.push('');
  sections.push('**Rules from RULEBOOK.md take precedence over all other rules in this file.**');
  sections.push('');
  sections.push('**Key Requirements:**');
  sections.push('- ‚úÖ Context7 MCP is REQUIRED for task creation');
  sections.push('- ‚úÖ All tasks MUST follow Rulebook task format');
  sections.push('- ‚úÖ Use `rulebook task create` to create tasks');
  sections.push('- ‚úÖ Always validate task format before committing');
  sections.push('- ‚ùå NEVER create tasks without checking RULEBOOK.md format requirements');
  sections.push('');
  sections.push('### ‚ö†Ô∏è CRITICAL: Task File Structure Rules');
  sections.push('');
  sections.push(
    '**MANDATORY**: When creating or updating tasks, you MUST follow the correct file structure:'
  );
  sections.push('');
  sections.push('**‚úÖ CORRECT File Structure:**');
  sections.push('- `proposal.md` - **Why** and **What Changes** (detailed explanations go here)');
  sections.push('- `tasks.md` - **ONLY checklist items** (simple `- [ ]` or `- [x]` format)');
  sections.push(
    '- `specs/<module>/spec.md` - **Technical specifications** (SHALL/MUST requirements)'
  );
  sections.push('- `design.md` - **Technical design decisions** (optional, for complex features)');
  sections.push('');
  sections.push('**‚ùå FORBIDDEN Practices:**');
  sections.push('- ‚ùå **NEVER** add long explanations or specifications in `tasks.md`');
  sections.push('- ‚ùå **NEVER** put technical details in `tasks.md` (use `specs/` instead)');
  sections.push('- ‚ùå **NEVER** create `README.md` or `README` files in task directories');
  sections.push('- ‚ùå **NEVER** create `PROCESS.md` or `PROCESS` files in task directories');
  sections.push('- ‚ùå **NEVER** create any file not listed in the correct structure above');
  sections.push('');
  sections.push('**What Goes Where:**');
  sections.push('');
  sections.push('1. **`proposal.md`** - Use for:');
  sections.push('   - Detailed "Why" explanations (minimum 20 characters)');
  sections.push('   - "What Changes" descriptions');
  sections.push('   - Impact analysis');
  sections.push('   - Business/technical rationale');
  sections.push('');
  sections.push('2. **`tasks.md`** - Use ONLY for:');
  sections.push('   - Simple checklist items: `- [ ] Task description`');
  sections.push('   - Status updates: `- [x] Completed task`');
  sections.push('   - Brief comments: `<!-- tested, coverage: 95% -->`');
  sections.push('   - **DO NOT** add long explanations, specifications, or technical details here');
  sections.push('');
  sections.push('3. **`specs/<module>/spec.md`** - Use for:');
  sections.push('   - Technical specifications with SHALL/MUST requirements');
  sections.push('   - Scenario definitions (Given/When/Then)');
  sections.push('   - Delta operations (ADDED/MODIFIED/REMOVED)');
  sections.push('   - All detailed technical requirements');
  sections.push('');
  sections.push('4. **`design.md`** - Use for (optional):');
  sections.push('   - Architecture decisions');
  sections.push('   - Technical design rationale');
  sections.push('   - Complex implementation details');
  sections.push('');
  sections.push('**Example of WRONG usage:**');
  sections.push('```markdown');
  sections.push('# tasks.md (WRONG - too much detail)');
  sections.push('');
  sections.push('## Implementation');
  sections.push('- [ ] Create authentication system');
  sections.push('  The system SHALL implement JWT-based authentication...');
  sections.push('  Users MUST be able to login with email and password...');
  sections.push('  The system MUST validate tokens...');
  sections.push('```');
  sections.push('');
  sections.push('**Example of CORRECT usage:**');
  sections.push('```markdown');
  sections.push('# tasks.md (CORRECT - simple checklist)');
  sections.push('');
  sections.push('## 1. Implementation Phase');
  sections.push('- [ ] 1.1 Create authentication module');
  sections.push('- [ ] 1.2 Add JWT token generation');
  sections.push('- [ ] 1.3 Implement password validation');
  sections.push('');
  sections.push('# specs/auth/spec.md (CORRECT - specifications here)');
  sections.push('');
  sections.push('## ADDED Requirements');
  sections.push('');
  sections.push('### Requirement: Authentication System');
  sections.push('The system SHALL implement JWT-based authentication.');
  sections.push('');
  sections.push('#### Scenario: User Login');
  sections.push('Given a user with valid credentials');
  sections.push('When the user submits login form');
  sections.push('Then the system MUST return a JWT token');
  sections.push('```');
  sections.push('');
  sections.push('**Remember:**');
  sections.push('- ‚úÖ `tasks.md` = Simple checklist only');
  sections.push('- ‚úÖ `proposal.md` = Why and what changes');
  sections.push('- ‚úÖ `specs/` = Technical specifications');
  sections.push('- ‚ùå No README, PROCESS, or other files');
  sections.push('');
  sections.push(
    `**For complete task management guidelines, see: \`/${rulebookDir}/specs/RULEBOOK.md\`**`
  );
  sections.push('');
  sections.push('---');
  sections.push('');

  // Core rules summary (detailed rules in /rulebook/)
  sections.push('## Core Rules');
  sections.push('');
  sections.push('This project uses @hivellm/rulebook standards.');
  sections.push('');
  sections.push('**CRITICAL RULES:**');
  sections.push('1. **ALWAYS check `RULEBOOK.md` first** when creating tasks');
  sections.push(`2. Write tests first (${config.coverageThreshold}%+ coverage required)`);
  sections.push('3. Run quality checks before committing:');
  sections.push('   - Type check / Compiler check');
  sections.push('   - Linter (no warnings allowed)');
  sections.push('   - All tests (100% pass rate)');
  sections.push('   - Coverage check');
  sections.push('4. Update docs/ when implementing features');
  sections.push('5. Follow strict documentation structure');
  sections.push(
    '6. **NEVER run destructive deletions (`rm -rf`) in this repository; when adding submodules always use `git submodule add`.**'
  );
  sections.push('7. **Temporary files and scripts**:');
  sections.push('   - ‚úÖ ALL scripts MUST be created in `/scripts` directory');
  sections.push('   - ‚úÖ ALL temporary files (test, log, debug) MUST be in `/scripts`');
  sections.push('   - ‚úÖ ALL temporary files MUST be removed immediately after use (MANDATORY)');
  sections.push('   - ‚ùå NEVER create temporary files in project root or outside `/scripts`');
  sections.push('   - ‚ùå NEVER leave temporary files after use - clean up before committing');
  sections.push('');
  sections.push('## Detailed Rules');
  sections.push('');
  sections.push(
    `For comprehensive rules, see the corresponding files in \`/${rulebookDir}/specs/\`:`
  );
  sections.push('');

  // RULEBOOK.md is always first in the list (highest precedence)
  sections.push(
    `- \`/${rulebookDir}/specs/RULEBOOK.md\` - **Task management rules (HIGHEST PRECEDENCE)**`
  );

  // Only reference QUALITY_ENFORCEMENT if not in light mode
  if (!config.lightMode) {
    sections.push(`- \`/${rulebookDir}/specs/QUALITY_ENFORCEMENT.md\` - Quality enforcement rules`);
  }

  // Only reference GIT if enabled
  if (config.includeGitWorkflow) {
    sections.push(`- \`/${rulebookDir}/specs/GIT.md\` - Git workflow rules`);
  }

  // Reference PLANS.md for session continuity
  sections.push(`- \`PLANS.md\` - **Session scratchpad** (read at session start for current task context)`);
  sections.push('');
  sections.push(`Language-specific rules are in \`/${rulebookDir}/specs/\`.`);
  sections.push(`Module-specific patterns are in \`/${rulebookDir}/specs/\`.`);
  sections.push('');
  sections.push('## Persistent Memory System');
  sections.push('');
  sections.push('This project uses a **persistent memory system** with hybrid BM25+vector search.');
  sections.push(
    'Memory is **enabled by default** and persists across sessions for maintaining context and preserving learnings.'
  );
  sections.push('');
  sections.push('**MANDATORY: You MUST actively use memory to preserve context and learnings.**');
  sections.push('');
  sections.push('**Status**: ‚úÖ Enabled by default in `.rulebook` configuration');
  sections.push('');
  sections.push('### Key Features');
  sections.push('');
  sections.push(
    '- **Rich Contextual Summaries**: Memories auto-extract summaries with key concepts, decisions, patterns, gotchas'
  );
  sections.push(
    '- **Hybrid Search**: BM25 keyword search + HNSW vector semantic search for relevant results'
  );
  sections.push(
    '- **3-Layer Search Pattern**: Compact results ‚Üí Timeline context ‚Üí Full details (token-efficient)'
  );
  sections.push('- **Auto-Capture**: Implementation outputs from AI agents automatically captured');
  sections.push('- **Zero Native Dependencies**: Pure WASM + TypeScript, works on all platforms');
  sections.push('');
  sections.push('### When to Save to Memory');
  sections.push('');
  sections.push('Save to memory whenever you:');
  sections.push('- **Make an architectural decision** ‚Äî why you chose one approach over another');
  sections.push('- **Fix a bug** ‚Äî root cause and how it was resolved');
  sections.push('- **Discover something important** ‚Äî codebase patterns, gotchas, constraints');
  sections.push(
    '- **Implement a feature** ‚Äî design approach, patterns discovered, edge cases handled'
  );
  sections.push('- **Encounter an error** ‚Äî root cause and solution for future reference');
  sections.push('- **Receive user preferences** ‚Äî coding style, conventions, workflow preferences');
  sections.push('- **Complete a task or session** ‚Äî summarize what was accomplished and learnings');
  sections.push('');
  sections.push('### How to Save Memory');
  sections.push('');
  sections.push('Save memories with rich context for better future searches:');
  sections.push('');
  sections.push('**Via MCP:**');
  sections.push('```');
  sections.push('rulebook_memory_save({');
  sections.push('  type: "feature|decision|bugfix|discovery|refactor|change|observation",');
  sections.push('  title: "Short title (‚â§80 chars)",');
  sections.push(
    '  content: "Detailed explanation: what was done, why, key decisions, patterns, gotchas...",'
  );
  sections.push('  tags: ["relevant", "tags"]');
  sections.push('})');
  sections.push('```');
  sections.push('');
  sections.push('**Via CLI:**');
  sections.push('```bash');
  sections.push(
    'rulebook memory save "Detailed content here" --type feature --title "Brief Title" --tags tag1,tag2'
  );
  sections.push('```');
  sections.push('');
  sections.push(
    '**Summary Auto-Extraction**: Summaries are automatically extracted from content, capturing:'
  );
  sections.push('- Key concepts and decisions');
  sections.push('- Design patterns discovered');
  sections.push('- Gotchas and edge cases');
  sections.push('- Problem/solution context');
  sections.push('');
  sections.push('### When and How to Search Memory');
  sections.push('');
  sections.push('**At the START of every session**, search memory for relevant context:');
  sections.push('');
  sections.push('**Via MCP (3-Layer Search - token efficient):**');
  sections.push('```');
  sections.push(
    'Layer 1 - Compact search: rulebook_memory_search({ query: "your topic", mode: "hybrid", limit: 10 })'
  );
  sections.push('  ‚Üí Returns: id, title, type, score, summary (compact results)');
  sections.push('Layer 2 - Timeline: rulebook_memory_timeline({ memoryId: "abc-123", window: 5 })');
  sections.push('  ‚Üí Returns: 5 before/after chronologically');
  sections.push('Layer 3 - Full details: rulebook_memory_get({ ids: ["abc-123"] })');
  sections.push('  ‚Üí Returns: complete memory objects');
  sections.push('```');
  sections.push('');
  sections.push('**Via CLI:**');
  sections.push('```bash');
  sections.push(
    'rulebook memory search "authentication" --mode hybrid          # Keyword + semantic'
  );
  sections.push(
    'rulebook memory search "oauth" --type feature                  # Filter by memory type'
  );
  sections.push('rulebook memory list --limit 10                               # Recent memories');
  sections.push('```');
  sections.push('');
  sections.push('Also search when:');
  sections.push("- Working on code you've touched before");
  sections.push('- The user references a past discussion or decision');
  sections.push('- You need context about why something was done a certain way');
  sections.push('- **Before implementing similar features** ‚Äî find past patterns and gotchas');
  sections.push('');
  sections.push('### Session Workflow');
  sections.push('');
  sections.push('**Complete memory-enhanced workflow:**');
  sections.push('1. **Start of session**: Search memory for relevant past context');
  sections.push('2. **During work**: Save discoveries, patterns, decisions as they happen');
  sections.push('3. **After feature**: Save complete implementation with summaries');
  sections.push('4. **End of session**: Save session summary for future sessions');
  sections.push('');
  sections.push('### Session Summary');
  sections.push('');
  sections.push('Before ending a session or when context is getting long, save a summary:');
  sections.push('```');
  sections.push('type: observation');
  sections.push('title: "Session summary: <date or topic>"');
  sections.push('content: "Accomplished: ... | Pending: ... | Key decisions: ..."');
  sections.push('```');
  sections.push('');
  sections.push('When in doubt, ask to review @AGENTS.md first.');
  sections.push('');
  sections.push('## Ralph Autonomous Loop');
  sections.push('');
  sections.push(
    'This project is **enabled for Ralph autonomous loop** for iterative feature implementation.'
  );
  sections.push(
    'Ralph automates multi-iteration development with fresh AI context per iteration, persisting learnings via git and progress logs.'
  );
  sections.push('');
  sections.push('**Status**: ‚úÖ Enabled by default in `.rulebook` configuration');
  sections.push('');
  sections.push('### Quick Start');
  sections.push('');
  sections.push('```bash');
  sections.push('# 1. Create tasks');
  sections.push('rulebook task create <task-id>');
  sections.push('');
  sections.push('# 2. Initialize Ralph');
  sections.push('rulebook ralph init');
  sections.push('');
  sections.push('# 3. Run autonomous loop');
  sections.push('rulebook ralph run --max-iterations 10');
  sections.push('');
  sections.push('# 4. Monitor progress');
  sections.push('rulebook ralph status');
  sections.push('rulebook ralph history');
  sections.push('```');
  sections.push('');
  sections.push('### Key Commands');
  sections.push('');
  sections.push(
    '- `rulebook ralph init` ‚Äî Initialize Ralph configuration and create PRD from tasks'
  );
  sections.push(
    '- `rulebook ralph run [--max-iterations N] [--tool claude|amp]` ‚Äî Execute autonomous loop'
  );
  sections.push('- `rulebook ralph status` ‚Äî Show loop progress and current iteration');
  sections.push('- `rulebook ralph history` ‚Äî Display iteration history and learnings');
  sections.push('- `rulebook ralph pause` ‚Äî Gracefully pause autonomous loop');
  sections.push('- `rulebook ralph resume` ‚Äî Resume from paused state');
  sections.push('');
  sections.push(
    'For detailed Ralph documentation, see `templates/skills/workflows/ralph/SKILL.md`'
  );
  sections.push('');
  sections.push('<!-- RULEBOOK:END -->');

  return sections.join('\n');
}

export async function generateLanguageRules(language: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'languages');
  const templatePath = path.join(templatesDir, `${language.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  return `<!-- ${language.toUpperCase()}:START -->\n# ${language.charAt(0).toUpperCase() + language.slice(1)} Rules\n\nLanguage-specific rules for ${language}.\n<!-- ${language.toUpperCase()}:END -->\n`;
}

export async function generateFrameworkRules(framework: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'frameworks');
  const templatePath = path.join(templatesDir, `${framework.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  const title = framework.charAt(0).toUpperCase() + framework.slice(1);
  return `<!-- ${framework.toUpperCase()}:START -->
# ${title} Framework Rules

Framework-specific rules for ${title}.
<!-- ${framework.toUpperCase()}:END -->
`;
}

export async function generateModuleRules(module: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'modules');
  // Try UPPERCASE.md first, then kebab-case.md (e.g. sequential_thinking ‚Üí sequential-thinking.md)
  const candidates = [
    path.join(templatesDir, `${module.toUpperCase()}.md`),
    path.join(templatesDir, `${module.toLowerCase().replace(/_/g, '-')}.md`),
  ];

  for (const templatePath of candidates) {
    if (await fileExists(templatePath)) {
      return await readFile(templatePath);
    }
  }

  return `<!-- ${module.toUpperCase()}:START -->\n# ${module.charAt(0).toUpperCase() + module.slice(1)} Instructions\n\nModule-specific instructions for ${module}.\n<!-- ${module.toUpperCase()}:END -->\n`;
}

export async function generateServiceRules(service: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'services');
  // Convert service name to template filename (e.g., 'azure_blob' -> 'AZURE_BLOB.md')
  const serviceName = service.toUpperCase().replace(/-/g, '_');
  const templatePath = path.join(templatesDir, `${serviceName}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  const serviceTitle = service
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');

  return `<!-- ${serviceName}:START -->\n# ${serviceTitle} Instructions\n\nService-specific instructions for ${serviceTitle}.\n<!-- ${serviceName}:END -->\n`;
}

export async function generateGitRules(pushMode: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'git');
  const templatePath = path.join(templatesDir, 'GIT_WORKFLOW.md');

  let gitRules = '';

  if (await fileExists(templatePath)) {
    gitRules = await readFile(templatePath);
  } else {
    gitRules = `<!-- GIT:START -->\n# Git Workflow Rules\n\nGit workflow guidelines for this project.\n<!-- GIT:END -->\n`;
  }

  // Add push mode configuration
  const pushModeConfig = `\n**AI Assistant Git Push Mode**: ${pushMode.toUpperCase()}\n\n`;

  const pushModeInstructions = {
    manual: `**CRITICAL**: Never execute \`git push\` commands automatically.
Always provide push commands for manual execution by the user.

Example:
\`\`\`
‚úã MANUAL ACTION REQUIRED:
Run these commands manually (SSH password may be required):
  git push origin main
  git push origin v1.0.0
\`\`\``,

    prompt: `**CRITICAL**: Always ask user permission before pushing.

Example:
\`\`\`
Ready to push changes. Execute these commands?
  git push origin main

[Y/n]:
\`\`\``,

    auto: `**INFO**: Automatic push enabled.
AI assistants may execute push commands automatically.

‚ö†Ô∏è Only use this mode if:
- SSH key has no password
- GitHub CLI is authenticated
- You trust the AI assistant completely`,
  };

  // Insert push mode config after <!-- GIT:START -->
  gitRules = gitRules.replace(
    '<!-- GIT:START -->',
    `<!-- GIT:START -->\n${pushModeConfig}${pushModeInstructions[pushMode as keyof typeof pushModeInstructions]}\n`
  );

  return gitRules;
}

/**
 * Write modular directive file to /rulebook/ directory
 * Adds header and footer comments for consistency
 */
async function writeModularFile(
  projectRoot: string,
  fileName: string,
  content: string,
  rulebookDir: string = '.rulebook'
): Promise<void> {
  const specsPath = path.join(projectRoot, rulebookDir, 'specs');
  await ensureDir(specsPath);
  const filePath = path.join(specsPath, `${fileName}.md`);

  // Add header comment if not already present
  const headerComment = `<!-- ${fileName}:START -->\n`;
  const footerComment = `\n<!-- ${fileName}:END -->`;

  let finalContent = content.trim();

  // Add header if not present
  if (!finalContent.startsWith(headerComment.trim())) {
    finalContent = headerComment + finalContent;
  }

  // Add footer if not present
  if (!finalContent.endsWith(footerComment.trim())) {
    finalContent = finalContent + footerComment;
  }

  await writeFile(filePath, finalContent);
}

/**
 * Generate reference section for AGENTS.md
 */
function generateReferenceSection(
  name: string,
  fileName: string,
  description: string,
  quickRef: string[],
  rulebookDir: string = '.rulebook'
): string {
  const sections: string[] = [];
  sections.push(`### ${name}`);
  sections.push('');
  sections.push(`For comprehensive ${description}, see \`/${rulebookDir}/specs/${fileName}.md\``);
  sections.push('');
  sections.push('Quick reference:');
  for (const item of quickRef) {
    sections.push(`- ${item}`);
  }
  sections.push('');
  return sections.join('\n');
}

/**
 * Generate language reference for AGENTS.md
 */
function generateLanguageReference(language: string, rulebookDir: string = '.rulebook'): string {
  const languageName = language.charAt(0).toUpperCase() + language.slice(1);
  const quickRef = [
    'Type safety and strict mode',
    'Code quality standards',
    'Testing requirements (95%+ coverage)',
    'Package management',
    'Error handling patterns',
  ];
  return generateReferenceSection(
    `${languageName} Development Rules`,
    language.toUpperCase(),
    `${languageName}-specific guidelines`,
    quickRef,
    rulebookDir
  );
}

/**
 * Generate framework reference for AGENTS.md
 */
function generateFrameworkReference(framework: string, rulebookDir: string = '.rulebook'): string {
  const frameworkName = framework.charAt(0).toUpperCase() + framework.slice(1);
  const quickRef = [
    'Framework-specific patterns',
    'Component structure',
    'Best practices',
    'Testing conventions',
  ];
  return generateReferenceSection(
    `${frameworkName} Framework Rules`,
    framework.toUpperCase(),
    `${frameworkName}-specific guidelines`,
    quickRef,
    rulebookDir
  );
}

/**
 * Generate module reference for AGENTS.md
 */
function generateModuleReference(module: string, rulebookDir: string = '.rulebook'): string {
  const moduleName = module.charAt(0).toUpperCase() + module.slice(1).replace(/_/g, ' ');
  const quickRef = ['Module-specific instructions', 'Usage guidelines', 'Integration patterns'];
  return generateReferenceSection(
    `${moduleName} Instructions`,
    module.toUpperCase(),
    `${moduleName}-specific instructions`,
    quickRef,
    rulebookDir
  );
}

/**
 * Generate service reference for AGENTS.md
 */
function generateServiceReference(service: string, rulebookDir: string = '.rulebook'): string {
  const serviceName = service
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
  const serviceId = service.toUpperCase().replace(/-/g, '_');
  const quickRef = ['Connection setup', 'Basic operations', 'Best practices', 'Configuration'];
  return generateReferenceSection(
    `${serviceName} Instructions`,
    serviceId,
    `${serviceName}-specific instructions`,
    quickRef,
    rulebookDir
  );
}

/**
 * Load project configuration from .rulebook file
 */
async function loadProjectConfigFromRulebook(
  projectRoot: string = process.cwd()
): Promise<Partial<ProjectConfig>> {
  const { createConfigManager } = await import('./config-manager.js');
  const configManager = createConfigManager(projectRoot);

  try {
    const rulebookConfig = await configManager.loadConfig();

    // Map RulebookConfig to ProjectConfig
    const projectConfig: Partial<ProjectConfig> = {
      languages: rulebookConfig.languages || [],
      frameworks: rulebookConfig.frameworks || [],
      modules: rulebookConfig.modules || [],
      services: rulebookConfig.services || [],
      modular: rulebookConfig.modular !== false, // Default to true
      rulebookDir: rulebookConfig.rulebookDir || '.rulebook',
    };

    return projectConfig;
  } catch {
    // If .rulebook doesn't exist or can't be read, return empty config
    return {};
  }
}

/**
 * Generate modular AGENTS.md with references
 */
export async function generateModularAgents(
  config: ProjectConfig,
  projectRoot: string = process.cwd()
): Promise<string> {
  // Load saved configuration from .rulebook and merge with provided config
  const savedConfig = await loadProjectConfigFromRulebook(projectRoot);

  // Merge: saved config takes precedence for languages/frameworks/modules/services
  // provided config takes precedence for other settings (like rulebookDir when explicitly set)
  const mergedConfig: ProjectConfig = {
    ...config,
    languages: savedConfig.languages?.length ? savedConfig.languages : config.languages,
    frameworks: savedConfig.frameworks?.length ? savedConfig.frameworks : config.frameworks || [],
    modules: savedConfig.modules?.length ? savedConfig.modules : config.modules,
    services: savedConfig.services?.length ? savedConfig.services : config.services || [],
    modular: savedConfig.modular !== undefined ? savedConfig.modular : config.modular !== false,
    // rulebookDir: provided config takes precedence if explicitly set, otherwise use saved or default
    rulebookDir: config.rulebookDir || savedConfig.rulebookDir || '.rulebook',
  };

  const rulebookDir = mergedConfig.rulebookDir || '.rulebook';
  const sections: string[] = [];

  // Add Rulebook section (core rules stay embedded - simplified)
  sections.push(await generateAgentsContent(mergedConfig));
  sections.push('');

  // Write RULEBOOK.md to /rulebook/ (ALWAYS included - highest precedence)
  const rulebookContent = await generateCoreRules('RULEBOOK');
  await writeModularFile(projectRoot, 'RULEBOOK', rulebookContent.trim(), rulebookDir);

  // Write QUALITY_ENFORCEMENT to /rulebook/ (always included unless light mode)
  if (!mergedConfig.lightMode) {
    const enforcementContent = await generateCoreRules('QUALITY_ENFORCEMENT');
    await writeModularFile(
      projectRoot,
      'QUALITY_ENFORCEMENT',
      enforcementContent.trim(),
      rulebookDir
    );
  }

  // Write Git workflow rules to /.rulebook/specs/GIT.md
  if (mergedConfig.includeGitWorkflow) {
    const gitRules = await generateGitRules(mergedConfig.gitPushMode || 'manual');
    await writeModularFile(projectRoot, 'GIT', gitRules.trim(), rulebookDir);
  }

  // Write language files and add references
  if (mergedConfig.languages.length > 0) {
    sections.push('## Language-Specific Rules');
    sections.push('');
    sections.push(
      `The following languages are configured for this project. For detailed rules, see the corresponding files in \`/${rulebookDir}/specs/\`:`
    );
    sections.push('');

    // Write all language files first
    for (const language of mergedConfig.languages) {
      const langRules = await generateLanguageRules(language);
      await writeModularFile(projectRoot, language.toUpperCase(), langRules, rulebookDir);
    }

    // Then add all references together
    for (const language of mergedConfig.languages) {
      sections.push(generateLanguageReference(language, rulebookDir));
    }

    sections.push(
      `**Usage**: When working with language-specific code, reference the corresponding \`/${rulebookDir}/specs/[LANGUAGE].md\` file for detailed guidelines.`
    );
    sections.push('');
  }

  // Write framework files and add references
  if (mergedConfig.frameworks && mergedConfig.frameworks.length > 0) {
    sections.push('## Framework-Specific Rules');
    sections.push('');
    sections.push(
      `The following frameworks are configured for this project. For detailed rules, see the corresponding files in \`/${rulebookDir}/specs/\`:`
    );
    sections.push('');

    // Write all framework files first
    for (const framework of mergedConfig.frameworks) {
      const frameworkRules = await generateFrameworkRules(framework);
      await writeModularFile(projectRoot, framework.toUpperCase(), frameworkRules, rulebookDir);
    }

    // Then add all references together
    for (const framework of mergedConfig.frameworks) {
      sections.push(generateFrameworkReference(framework, rulebookDir));
    }

    sections.push('');
    sections.push(
      `**Usage**: When working with framework-specific code, reference the corresponding \`/${rulebookDir}/specs/[FRAMEWORK].md\` file for detailed guidelines.`
    );
    sections.push('');
  }

  // Write module files and add references
  // First, write AGENT_AUTOMATION if not minimal (core file, not module)
  if (!mergedConfig.minimal) {
    const agentAutomation = await generateCoreRules('AGENT_AUTOMATION');
    await writeModularFile(projectRoot, 'AGENT_AUTOMATION', agentAutomation, rulebookDir);
  }

  // Write MULTI_AGENT directives (after AGENT_AUTOMATION)
  if (!mergedConfig.minimal) {
    const multiAgentContent = await generateCoreRules('MULTI_AGENT');
    await writeModularFile(projectRoot, 'MULTI_AGENT', multiAgentContent, rulebookDir);
  }

  // Then handle all modules together
  const allModules: string[] = [];
  if (!mergedConfig.minimal) {
    allModules.push('agent_automation');
    allModules.push('multi_agent');
  }
  allModules.push(...mergedConfig.modules);

  if (allModules.length > 0) {
    sections.push('## Module-Specific Instructions');
    sections.push('');
    sections.push(
      `The following modules are configured for this project. For detailed instructions, see the corresponding files in \`/${rulebookDir}/specs/\`:`
    );
    sections.push('');

    // Write all module files first (except AGENT_AUTOMATION which is already written)
    for (const module of mergedConfig.modules) {
      const moduleRules = await generateModuleRules(module);
      await writeModularFile(projectRoot, module.toUpperCase(), moduleRules, rulebookDir);
    }

    // Then add all references together
    if (!mergedConfig.minimal) {
      sections.push(generateModuleReference('agent_automation', rulebookDir));
      sections.push(generateModuleReference('multi_agent', rulebookDir));
    }
    for (const module of mergedConfig.modules) {
      sections.push(generateModuleReference(module, rulebookDir));
    }

    sections.push(
      `**Usage**: When working with module-specific features, reference the corresponding \`/${rulebookDir}/specs/[MODULE].md\` file for detailed instructions.`
    );
    sections.push('');
  }

  // Write service files and add references
  if (mergedConfig.services && mergedConfig.services.length > 0) {
    sections.push('## Service-Specific Instructions');
    sections.push('');
    sections.push(
      `The following services are configured for this project. For detailed instructions, see the corresponding files in \`/${rulebookDir}/specs/\`:`
    );
    sections.push('');

    // Write all service files first
    for (const service of mergedConfig.services) {
      const serviceRules = await generateServiceRules(service);
      const serviceId = service.toUpperCase().replace(/-/g, '_');
      await writeModularFile(projectRoot, serviceId, serviceRules, rulebookDir);
    }

    // Then add all references together
    for (const service of mergedConfig.services) {
      sections.push(generateServiceReference(service, rulebookDir));
    }

    sections.push(
      `**Usage**: When working with service-specific features, reference the corresponding \`/${rulebookDir}/specs/[SERVICE].md\` file for detailed instructions.`
    );
    sections.push('');
  }

  // Add enabled skills section (v2.0)
  try {
    const { SkillsManager, getDefaultTemplatesPath } = await import('./skills-manager.js');
    const { createConfigManager } = await import('./config-manager.js');

    const configManager = createConfigManager(projectRoot);
    const rulebookConfig = await configManager.loadConfig();

    if (rulebookConfig.skills?.enabled && rulebookConfig.skills.enabled.length > 0) {
      const skillsManager = new SkillsManager(getDefaultTemplatesPath(), projectRoot);
      const enabledSkills = await skillsManager.getEnabledSkills(rulebookConfig);

      // Add capabilities summary
      if (enabledSkills.length > 0) {
        sections.push('## Project Capabilities');
        sections.push('');
        sections.push('This project has the following AI-assisted capabilities enabled:');
        sections.push('');

        // Group skills by category for summary
        const categorySummary = new Map<string, string[]>();
        for (const skill of enabledSkills) {
          const category = skill.category;
          if (!categorySummary.has(category)) {
            categorySummary.set(category, []);
          }
          categorySummary.get(category)?.push(skill.metadata.name);
        }

        for (const [category, skills] of categorySummary.entries()) {
          const categoryLabel = category.charAt(0).toUpperCase() + category.slice(1);
          sections.push(`- **${categoryLabel}**: ${skills.join(', ')}`);
        }

        sections.push('');
        sections.push('Use `rulebook skill list` to see all available skills.');
        sections.push('Use `rulebook skill add <skill-id>` to enable additional skills.');
        sections.push('');
      }

      // Add skills content (includes index and detailed rules)
      const skillsContent = await skillsManager.mergeSkillsContent(rulebookConfig);
      if (skillsContent) {
        sections.push(skillsContent);
      }
    }
  } catch {
    // Skills not configured or error loading - skip silently
  }

  // Add monorepo package index and generate per-package AGENTS.md if monorepo detected
  try {
    const { detectMonorepo } = await import('./detector.js');
    const monorepo = await detectMonorepo(projectRoot);
    if (monorepo.detected && monorepo.packages.length > 0) {
      sections.push('## Monorepo Package Index');
      sections.push('');
      sections.push(`Monorepo tool: **${monorepo.tool}**`);
      sections.push('');
      sections.push('Packages:');
      for (const pkg of monorepo.packages) {
        sections.push(`- \`${pkg}/\` ‚Äî see \`${pkg}/AGENTS.md\` for package-specific rules`);
      }
      sections.push('');

      // Generate per-package AGENTS.md files
      for (const pkg of monorepo.packages) {
        await generatePackageAgentsMd(path.join(projectRoot, pkg), mergedConfig, projectRoot).catch(
          () => {
            /* skip on error */
          }
        );
      }
    }
  } catch {
    // Monorepo detection failed ‚Äî skip silently
  }

  // Generate .cursor/rules/*.mdc files if Cursor is detected
  try {
    const { isCursorInstalled, generateCursorMdcRules } = await import('./cursor-mdc-generator.js');
    if (isCursorInstalled(projectRoot)) {
      const { createConfigManager } = await import('./config-manager.js');
      const configManager = createConfigManager(projectRoot);
      const rulebookConfig = await configManager.loadConfig();
      const ralphEnabled = rulebookConfig.ralph?.enabled ?? false;

      await generateCursorMdcRules(projectRoot, {
        languages: mergedConfig.languages,
        ralphEnabled,
        rulebookDir: rulebookDir,
      });
    }
  } catch {
    // Cursor MDC generation failed - skip silently
  }

  return sections.join('\n').trim() + '\n';
}

/**
 * Generate a minimal AGENTS.md for an individual package inside a monorepo.
 * Inherits language detection from the package root and links back to the root AGENTS.md.
 */
export async function generatePackageAgentsMd(
  packageRoot: string,
  rootConfig: ProjectConfig,
  monorepoRoot: string
): Promise<void> {
  const { existsSync } = await import('fs');
  const { detectProject } = await import('./detector.js');
  const agentsPath = path.join(packageRoot, 'AGENTS.md');

  // Don't overwrite if already customized (has RULEBOOK markers)
  if (existsSync(agentsPath)) {
    const existing = await readFile(agentsPath).catch(() => '');
    if (existing.includes('<!-- RULEBOOK:START -->')) return;
  }

  // Detect languages specific to this package
  const pkgDetection = await detectProject(packageRoot).catch(() => null);
  const langList: string[] = pkgDetection
    ? pkgDetection.languages.map((l) => l.language as string)
    : rootConfig.languages;
  const relRoot = path.relative(packageRoot, monorepoRoot) || '..';

  const content = [
    '<!-- RULEBOOK:START -->',
    `# Package Agent Directives`,
    '',
    `> Part of a monorepo. Root rules: [\`${relRoot}/AGENTS.md\`](${relRoot}/AGENTS.md)`,
    '',
    '## Languages',
    '',
    langList.length > 0
      ? langList.map((l) => `- ${l.toUpperCase()}`).join('\n')
      : '- (inherits from root)',
    '',
    '## Rules',
    '',
    `- Follow root AGENTS.md for task management and quality gates`,
    `- Package-specific overrides go in \`AGENTS.override.md\` (if present)`,
    '<!-- RULEBOOK:END -->',
    '',
  ].join('\n');

  await writeFile(agentsPath, content);
}

/**
 * Generate lean AGENTS.md ‚Äî a lightweight index (< 3KB) referencing spec files.
 * All spec files are still written to .rulebook/specs/ by generateModularAgents.
 */
export async function generateLeanAgents(
  config: ProjectConfig,
  projectRoot: string = process.cwd()
): Promise<string> {
  // First run modular generation to ensure all spec files are up to date
  await generateModularAgents(config, projectRoot);

  const rulebookDir = config.rulebookDir || '.rulebook';

  // Load lean template
  const templatesDir = path.join(getTemplatesDir(), 'core');
  const leanTemplatePath = path.join(templatesDir, 'AGENTS_LEAN.md');
  let template = '';
  if (await fileExists(leanTemplatePath)) {
    template = await readFile(leanTemplatePath);
  } else {
    template = `<!-- RULEBOOK:START -->\n# Project Agent Directives\n\nSee \`/${rulebookDir}/specs/\` for all rules.\n\n- **Task Management**: \`/${rulebookDir}/specs/RULEBOOK.md\`\n- **Quality Gates**: \`/${rulebookDir}/specs/QUALITY_ENFORCEMENT.md\`\n- **Git Workflow**: \`/${rulebookDir}/specs/GIT.md\`\n<!-- RULEBOOK:END -->\n`;
  }

  // Build language refs
  const langRefs = config.languages
    .map((lang) => `- **${lang.toUpperCase()}**: \`/${rulebookDir}/specs/${lang.toUpperCase()}.md\``)
    .join('\n');
  template = template.replace('LANGUAGE_REFS', langRefs || '_None configured_');

  // Build module refs (core + user modules)
  const coreModules = config.minimal ? [] : ['agent_automation', 'multi_agent'];
  const allModules = [...coreModules, ...(config.modules || [])];
  const moduleRefs = allModules
    .map((mod) => `- **${mod.toUpperCase()}**: \`/${rulebookDir}/specs/${mod.toUpperCase()}.md\``)
    .join('\n');
  template = template.replace('MODULE_REFS', moduleRefs || '_None configured_');

  return template;
}

/**
 * Generate full AGENTS.md (modular by default, legacy mode available)
 */
export async function generateFullAgents(
  config: ProjectConfig,
  projectRoot: string = process.cwd()
): Promise<string> {
  // Lean mode: generate a lightweight index AGENTS.md
  if (config.agentsMode === 'lean') {
    return await generateLeanAgents(config, projectRoot);
  }

  // Use modular generation by default (unless explicitly disabled)
  if (config.modular !== false) {
    return await generateModularAgents(config, projectRoot);
  }

  // Legacy mode: embed all templates
  const sections: string[] = [];

  // Add Rulebook section
  sections.push(await generateAgentsContent(config));
  sections.push('');

  // Add RULEBOOK.md rules (ALWAYS included - highest precedence)
  const rulebookContent = await generateCoreRules('RULEBOOK');
  sections.push(rulebookContent);
  sections.push('');

  // Add language-specific rules
  for (const language of config.languages) {
    const langRules = await generateLanguageRules(language);
    sections.push(langRules);
    sections.push('');
  }

  // Add framework-specific rules
  for (const framework of config.frameworks || []) {
    const frameworkRules = await generateFrameworkRules(framework);
    sections.push(frameworkRules);
    sections.push('');
  }

  if (!config.minimal) {
    // Add AGENT_AUTOMATION (core file, not module) when not in minimal mode
    const agentAutomation = await generateCoreRules('AGENT_AUTOMATION');
    sections.push(agentAutomation);
    sections.push('');
  }

  // Add module-specific rules
  for (const module of config.modules) {
    const moduleRules = await generateModuleRules(module);
    sections.push(moduleRules);
    sections.push('');
  }

  // Add service-specific rules
  if (config.services && config.services.length > 0) {
    for (const service of config.services) {
      const serviceRules = await generateServiceRules(service);
      sections.push(serviceRules);
      sections.push('');
    }
  }

  // Add Git workflow rules if enabled
  if (config.includeGitWorkflow) {
    const gitRules = await generateGitRules(config.gitPushMode || 'manual');
    sections.push(gitRules);
    sections.push('');
  }

  return sections.join('\n').trim() + '\n';
}
