import path from 'path';
import { readFile, fileExists, writeFile, ensureDir } from '../utils/file-system.js';
import type { ProjectConfig } from '../types.js';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Resolve templates directory (handles both dev and production)
function getTemplatesDir(): string {
  // In production (dist/), templates are at package root
  // In development (src/), templates are at package root
  // Both resolve to same location
  return path.join(__dirname, '..', '..', 'templates');
}

export async function generateAgentsContent(config: ProjectConfig): Promise<string> {
  const sections: string[] = [];

  // Header comment
  sections.push('<!-- RULEBOOK:START -->');
  sections.push('# Project Rules');
  sections.push('');
  sections.push('Generated by @hivellm/rulebook');
  sections.push(`Generated at: ${new Date().toISOString()}`);
  sections.push('');

  // Core rules summary (detailed rules in /rulebook/)
  sections.push('## Core Rules');
  sections.push('');
  sections.push('This project uses @hivellm/rulebook standards.');
  sections.push('');
  sections.push('**CRITICAL RULES:**');
  sections.push('1. Always reference @AGENTS.md before coding');
  sections.push(`2. Write tests first (${config.coverageThreshold}%+ coverage required)`);
  sections.push('3. Run quality checks before committing:');
  sections.push('   - Type check / Compiler check');
  sections.push('   - Linter (no warnings allowed)');
  sections.push('   - All tests (100% pass rate)');
  sections.push('   - Coverage check');
  sections.push('4. Update docs/ when implementing features');
  sections.push('5. Follow strict documentation structure');
  sections.push('');
  const rulebookDir = config.rulebookDir || 'rulebook';

  sections.push('## Detailed Rules');
  sections.push('');
  sections.push(`For comprehensive rules, see the corresponding files in \`/${rulebookDir}/\`:`);
  sections.push('');

  // Only reference QUALITY_ENFORCEMENT if not in light mode
  if (!config.lightMode) {
    sections.push(`- \`/${rulebookDir}/QUALITY_ENFORCEMENT.md\` - Quality enforcement rules`);
  }

  // Only reference GIT if enabled
  if (config.includeGitWorkflow) {
    sections.push(`- \`/${rulebookDir}/GIT.md\` - Git workflow rules`);
  }

  sections.push('');
  sections.push(`Language-specific rules are in \`/${rulebookDir}/\`.`);
  sections.push(`Module-specific patterns are in \`/${rulebookDir}/\`.`);
  sections.push('');
  sections.push('When in doubt, ask to review @AGENTS.md first.');
  sections.push('');
  sections.push('<!-- RULEBOOK:END -->');

  return sections.join('\n');
}

export async function generateLanguageRules(language: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'languages');
  const templatePath = path.join(templatesDir, `${language.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  return `<!-- ${language.toUpperCase()}:START -->\n# ${language.charAt(0).toUpperCase() + language.slice(1)} Rules\n\nLanguage-specific rules for ${language}.\n<!-- ${language.toUpperCase()}:END -->\n`;
}

export async function generateFrameworkRules(framework: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'frameworks');
  const templatePath = path.join(templatesDir, `${framework.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  const title = framework.charAt(0).toUpperCase() + framework.slice(1);
  return `<!-- ${framework.toUpperCase()}:START -->
# ${title} Framework Rules

Framework-specific rules for ${title}.
<!-- ${framework.toUpperCase()}:END -->
`;
}

export async function generateModuleRules(module: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'modules');
  const templatePath = path.join(templatesDir, `${module.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  return `<!-- ${module.toUpperCase()}:START -->\n# ${module.charAt(0).toUpperCase() + module.slice(1)} Instructions\n\nModule-specific instructions for ${module}.\n<!-- ${module.toUpperCase()}:END -->\n`;
}

export async function generateGitRules(pushMode: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'git');
  const templatePath = path.join(templatesDir, 'GIT_WORKFLOW.md');

  let gitRules = '';

  if (await fileExists(templatePath)) {
    gitRules = await readFile(templatePath);
  } else {
    gitRules = `<!-- GIT:START -->\n# Git Workflow Rules\n\nGit workflow guidelines for this project.\n<!-- GIT:END -->\n`;
  }

  // Add push mode configuration
  const pushModeConfig = `\n**AI Assistant Git Push Mode**: ${pushMode.toUpperCase()}\n\n`;

  const pushModeInstructions = {
    manual: `**CRITICAL**: Never execute \`git push\` commands automatically.
Always provide push commands for manual execution by the user.

Example:
\`\`\`
✋ MANUAL ACTION REQUIRED:
Run these commands manually (SSH password may be required):
  git push origin main
  git push origin v1.0.0
\`\`\``,

    prompt: `**CRITICAL**: Always ask user permission before pushing.

Example:
\`\`\`
Ready to push changes. Execute these commands?
  git push origin main

[Y/n]:
\`\`\``,

    auto: `**INFO**: Automatic push enabled.
AI assistants may execute push commands automatically.

⚠️ Only use this mode if:
- SSH key has no password
- GitHub CLI is authenticated
- You trust the AI assistant completely`,
  };

  // Insert push mode config after <!-- GIT:START -->
  gitRules = gitRules.replace(
    '<!-- GIT:START -->',
    `<!-- GIT:START -->\n${pushModeConfig}${pushModeInstructions[pushMode as keyof typeof pushModeInstructions]}\n`
  );

  return gitRules;
}

/**
 * Write modular directive file to /rulebook/ directory
 * Adds header and footer comments for consistency
 */
async function writeModularFile(
  projectRoot: string,
  fileName: string,
  content: string,
  rulebookDir: string = 'rulebook'
): Promise<void> {
  const rulebookPath = path.join(projectRoot, rulebookDir);
  await ensureDir(rulebookPath);
  const filePath = path.join(rulebookPath, `${fileName}.md`);

  // Add header comment if not already present
  const headerComment = `<!-- ${fileName}:START -->\n`;
  const footerComment = `\n<!-- ${fileName}:END -->`;

  let finalContent = content.trim();

  // Add header if not present
  if (!finalContent.startsWith(headerComment.trim())) {
    finalContent = headerComment + finalContent;
  }

  // Add footer if not present
  if (!finalContent.endsWith(footerComment.trim())) {
    finalContent = finalContent + footerComment;
  }

  await writeFile(filePath, finalContent);
}

/**
 * Generate reference section for AGENTS.md
 */
function generateReferenceSection(
  name: string,
  fileName: string,
  description: string,
  quickRef: string[],
  rulebookDir: string = 'rulebook'
): string {
  const sections: string[] = [];
  sections.push(`### ${name}`);
  sections.push('');
  sections.push(`For comprehensive ${description}, see \`/${rulebookDir}/${fileName}.md\``);
  sections.push('');
  sections.push('Quick reference:');
  for (const item of quickRef) {
    sections.push(`- ${item}`);
  }
  return sections.join('\n');
}

/**
 * Generate language reference for AGENTS.md
 */
function generateLanguageReference(language: string, rulebookDir: string = 'rulebook'): string {
  const languageName = language.charAt(0).toUpperCase() + language.slice(1);
  const quickRef = [
    'Type safety and strict mode',
    'Code quality standards',
    'Testing requirements (95%+ coverage)',
    'Package management',
    'Error handling patterns',
  ];
  return generateReferenceSection(
    `${languageName} Development Rules`,
    language.toUpperCase(),
    `${languageName}-specific guidelines`,
    quickRef,
    rulebookDir
  );
}

/**
 * Generate framework reference for AGENTS.md
 */
function generateFrameworkReference(framework: string, rulebookDir: string = 'rulebook'): string {
  const frameworkName = framework.charAt(0).toUpperCase() + framework.slice(1);
  const quickRef = [
    'Framework-specific patterns',
    'Component structure',
    'Best practices',
    'Testing conventions',
  ];
  return generateReferenceSection(
    `${frameworkName} Framework Rules`,
    framework.toUpperCase(),
    `${frameworkName}-specific guidelines`,
    quickRef,
    rulebookDir
  );
}

/**
 * Generate module reference for AGENTS.md
 */
function generateModuleReference(module: string, rulebookDir: string = 'rulebook'): string {
  const moduleName = module.charAt(0).toUpperCase() + module.slice(1).replace(/_/g, ' ');
  const quickRef = ['Module-specific instructions', 'Usage guidelines', 'Integration patterns'];
  return generateReferenceSection(
    `${moduleName} Instructions`,
    module.toUpperCase(),
    `${moduleName}-specific instructions`,
    quickRef,
    rulebookDir
  );
}

/**
 * Load project configuration from .rulebook file
 */
async function loadProjectConfigFromRulebook(
  projectRoot: string = process.cwd()
): Promise<Partial<ProjectConfig>> {
  const { createConfigManager } = await import('./config-manager.js');
  const configManager = createConfigManager(projectRoot);

  try {
    const rulebookConfig = await configManager.loadConfig();

    // Map RulebookConfig to ProjectConfig
    const projectConfig: Partial<ProjectConfig> = {
      languages: rulebookConfig.languages || [],
      frameworks: rulebookConfig.frameworks || [],
      modules: rulebookConfig.modules || [],
      modular: rulebookConfig.modular !== false, // Default to true
      rulebookDir: rulebookConfig.rulebookDir || 'rulebook',
    };

    return projectConfig;
  } catch {
    // If .rulebook doesn't exist or can't be read, return empty config
    return {};
  }
}

/**
 * Generate modular AGENTS.md with references
 */
export async function generateModularAgents(
  config: ProjectConfig,
  projectRoot: string = process.cwd()
): Promise<string> {
  // Load saved configuration from .rulebook and merge with provided config
  const savedConfig = await loadProjectConfigFromRulebook(projectRoot);

  // Merge: saved config takes precedence for languages/frameworks/modules
  // provided config takes precedence for other settings (like rulebookDir when explicitly set)
  const mergedConfig: ProjectConfig = {
    ...config,
    languages: savedConfig.languages?.length ? savedConfig.languages : config.languages,
    frameworks: savedConfig.frameworks?.length ? savedConfig.frameworks : config.frameworks || [],
    modules: savedConfig.modules?.length ? savedConfig.modules : config.modules,
    modular: savedConfig.modular !== undefined ? savedConfig.modular : config.modular !== false,
    // rulebookDir: provided config takes precedence if explicitly set, otherwise use saved or default
    rulebookDir: config.rulebookDir || savedConfig.rulebookDir || 'rulebook',
  };

  const rulebookDir = mergedConfig.rulebookDir || 'rulebook';
  const sections: string[] = [];

  // Add Rulebook section (core rules stay embedded - simplified)
  sections.push(await generateAgentsContent(mergedConfig));
  sections.push('');

  // Write QUALITY_ENFORCEMENT to /rulebook/ (always included unless light mode)
  if (!mergedConfig.lightMode) {
    const enforcementPath = path.join(getTemplatesDir(), 'modules', 'QUALITY_ENFORCEMENT.md');
    if (await fileExists(enforcementPath)) {
      const enforcementContent = await readFile(enforcementPath);
      await writeModularFile(
        projectRoot,
        'QUALITY_ENFORCEMENT',
        enforcementContent.trim(),
        rulebookDir
      );
    }
  }

  // Write Git workflow rules to /rulebook/GIT.md
  if (mergedConfig.includeGitWorkflow) {
    const gitRules = await generateGitRules(mergedConfig.gitPushMode || 'manual');
    await writeModularFile(projectRoot, 'GIT', gitRules.trim(), rulebookDir);
  }

  // Write language files and add references
  if (mergedConfig.languages.length > 0) {
    sections.push('## Language-Specific Rules');
    sections.push('');
    sections.push(
      'The following languages are configured for this project. For detailed rules, see the corresponding files in `/rulebook/`:'
    );
    sections.push('');

    // Write all language files first
    for (const language of mergedConfig.languages) {
      const langRules = await generateLanguageRules(language);
      await writeModularFile(projectRoot, language.toUpperCase(), langRules, rulebookDir);
    }

    // Then add all references together
    for (const language of mergedConfig.languages) {
      sections.push(generateLanguageReference(language, rulebookDir));
    }

    sections.push(
      '**Usage**: When working with language-specific code, reference the corresponding `/rulebook/[LANGUAGE].md` file for detailed guidelines.'
    );
    sections.push('');
  }

  // Write framework files and add references
  if (mergedConfig.frameworks && mergedConfig.frameworks.length > 0) {
    sections.push('## Framework-Specific Rules');
    sections.push('');
    sections.push(
      'The following frameworks are configured for this project. For detailed rules, see the corresponding files in `/rulebook/`:'
    );
    sections.push('');

    // Write all framework files first
    for (const framework of mergedConfig.frameworks) {
      const frameworkRules = await generateFrameworkRules(framework);
      await writeModularFile(projectRoot, framework.toUpperCase(), frameworkRules, rulebookDir);
    }

    // Then add all references together
    for (const framework of mergedConfig.frameworks) {
      sections.push(generateFrameworkReference(framework, rulebookDir));
    }

    sections.push('');
    sections.push(
      '**Usage**: When working with framework-specific code, reference the corresponding `/rulebook/[FRAMEWORK].md` file for detailed guidelines.'
    );
    sections.push('');
  }

  // Write module files and add references
  // First, write AGENT_AUTOMATION if not minimal
  if (!mergedConfig.minimal) {
    const agentAutomation = await generateModuleRules('agent_automation');
    await writeModularFile(projectRoot, 'AGENT_AUTOMATION', agentAutomation, rulebookDir);
  }

  // Then handle all modules together
  const allModules: string[] = [];
  if (!mergedConfig.minimal) {
    allModules.push('agent_automation');
  }
  allModules.push(...mergedConfig.modules);

  if (allModules.length > 0) {
    sections.push('## Module-Specific Instructions');
    sections.push('');
    sections.push(
      'The following modules are configured for this project. For detailed instructions, see the corresponding files in `/rulebook/`:'
    );
    sections.push('');

    // Write all module files first (except AGENT_AUTOMATION which is already written)
    for (const module of mergedConfig.modules) {
      const moduleRules = await generateModuleRules(module);
      await writeModularFile(projectRoot, module.toUpperCase(), moduleRules, rulebookDir);
    }

    // Then add all references together
    if (!mergedConfig.minimal) {
      sections.push(generateModuleReference('agent_automation', rulebookDir));
    }
    for (const module of mergedConfig.modules) {
      sections.push(generateModuleReference(module, rulebookDir));
    }

    sections.push(
      '**Usage**: When working with module-specific features, reference the corresponding `/rulebook/[MODULE].md` file for detailed instructions.'
    );
    sections.push('');
  }

  return sections.join('\n').trim() + '\n';
}

/**
 * Generate full AGENTS.md (modular by default, legacy mode available)
 */
export async function generateFullAgents(
  config: ProjectConfig,
  projectRoot: string = process.cwd()
): Promise<string> {
  // Use modular generation by default (unless explicitly disabled)
  if (config.modular !== false) {
    return await generateModularAgents(config, projectRoot);
  }

  // Legacy mode: embed all templates
  const sections: string[] = [];

  // Add Rulebook section
  sections.push(await generateAgentsContent(config));
  sections.push('');

  // Add language-specific rules
  for (const language of config.languages) {
    const langRules = await generateLanguageRules(language);
    sections.push(langRules);
    sections.push('');
  }

  // Add framework-specific rules
  for (const framework of config.frameworks || []) {
    const frameworkRules = await generateFrameworkRules(framework);
    sections.push(frameworkRules);
    sections.push('');
  }

  if (!config.minimal) {
    // Add AGENT_AUTOMATION module when not in minimal mode
    const agentAutomation = await generateModuleRules('agent_automation');
    sections.push(agentAutomation);
    sections.push('');
  }

  // Add module-specific rules
  for (const module of config.modules) {
    const moduleRules = await generateModuleRules(module);
    sections.push(moduleRules);
    sections.push('');
  }

  // Add Git workflow rules if enabled
  if (config.includeGitWorkflow) {
    const gitRules = await generateGitRules(config.gitPushMode || 'manual');
    sections.push(gitRules);
    sections.push('');
  }

  return sections.join('\n').trim() + '\n';
}
