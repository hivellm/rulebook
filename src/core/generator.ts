import path from 'path';
import { readFile, fileExists } from '../utils/file-system.js';
import type { ProjectConfig } from '../types.js';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Resolve templates directory (handles both dev and production)
function getTemplatesDir(): string {
  // In production (dist/), templates are at package root
  // In development (src/), templates are at package root
  // Both resolve to same location
  return path.join(__dirname, '..', '..', 'templates');
}

export async function generateAgentsContent(config: ProjectConfig): Promise<string> {
  const sections: string[] = [];

  // Header comment
  sections.push('<!-- RULEBOOK:START -->');
  sections.push('# Project Rules');
  sections.push('');
  sections.push('Generated by @hivellm/rulebook');
  sections.push(`Generated at: ${new Date().toISOString()}`);
  sections.push('');

  // Documentation Standards
  sections.push('## Documentation Standards');
  sections.push('');
  if (config.strictDocs) {
    sections.push('**CRITICAL**: Minimize Markdown files. Keep documentation organized.');
    sections.push('');
    sections.push('### Allowed Root-Level Documentation');
    sections.push('Only these files are allowed in the project root:');
    sections.push('- ✅ `README.md` - Project overview and quick start');
    sections.push('- ✅ `CHANGELOG.md` - Version history and release notes');
    sections.push('- ✅ `AGENTS.md` - This file (AI assistant instructions)');
    sections.push('- ✅ `LICENSE` - Project license');
    sections.push('- ✅ `CONTRIBUTING.md` - Contribution guidelines');
    sections.push('- ✅ `CODE_OF_CONDUCT.md` - Code of conduct');
    sections.push('- ✅ `SECURITY.md` - Security policy');
    sections.push('');
    sections.push('### All Other Documentation');
    sections.push('**ALL other documentation MUST go in `/docs` directory**:');
    sections.push('- `/docs/ARCHITECTURE.md` - System architecture');
    sections.push('- `/docs/DEVELOPMENT.md` - Development guide');
    sections.push('- `/docs/ROADMAP.md` - Project roadmap');
    sections.push('- `/docs/DAG.md` - Component dependencies (DAG)');
    sections.push('- `/docs/specs/` - Feature specifications');
    sections.push('- `/docs/sdks/` - SDK documentation');
    sections.push('- `/docs/protocols/` - Protocol specifications');
    sections.push('- `/docs/guides/` - Developer guides');
    sections.push('- `/docs/diagrams/` - Architecture diagrams');
    sections.push('- `/docs/benchmarks/` - Performance benchmarks');
    sections.push('- `/docs/versions/` - Version release reports');
    sections.push('');
  } else {
    sections.push('Documentation should be well-organized in the `/docs` directory.');
    sections.push('');
  }

  // Testing Requirements
  sections.push('## Testing Requirements');
  sections.push('');
  sections.push('**CRITICAL**: All features must have comprehensive tests.');
  sections.push('');
  sections.push(`- **Minimum Coverage**: ${config.coverageThreshold}%`);
  sections.push('- **Test Location**: `/tests` directory in project root');
  sections.push('- **Test Execution**: 100% of tests MUST pass before moving to next task');
  sections.push('- **Test First**: Write tests based on specifications before implementation');
  sections.push('');

  // Feature Development Workflow
  sections.push('## Feature Development Workflow');
  sections.push('');
  sections.push('**CRITICAL**: Follow this workflow for all feature development.');
  sections.push('');
  sections.push('1. **Check Specifications First**:');
  sections.push('   - Read `/docs/specs/` for feature specifications');
  sections.push('   - Review `/docs/ARCHITECTURE.md` for system design');
  sections.push('   - Check `/docs/ROADMAP.md` for implementation timeline');
  sections.push('   - Review `/docs/DAG.md` for component dependencies');
  sections.push('');
  sections.push('2. **Implement with Tests**:');
  sections.push('   - Write tests in `/tests` directory first');
  sections.push('   - Implement feature following specifications');
  sections.push('   - Ensure tests pass and meet coverage threshold');
  sections.push('');
  sections.push('3. **Quality Checks**:');
  sections.push('   - Run code formatter');
  sections.push('   - Run linter (must pass with no warnings)');
  sections.push('   - Run all tests (must be 100% passing)');
  sections.push('   - Verify coverage meets threshold');
  sections.push('');
  sections.push('4. **Update Documentation**:');
  sections.push('   - Update `/docs/ROADMAP.md` progress');
  sections.push('   - Update feature specs if implementation differs');
  sections.push('   - Document any deviations with justification');
  sections.push('');

  // Rules Ignore
  sections.push('## Rules Configuration');
  sections.push('');
  sections.push('Rules can be selectively disabled using `.rulesignore` file in project root.');
  sections.push('');
  sections.push('Example `.rulesignore`:');
  sections.push('```');
  sections.push('# Ignore coverage requirement');
  sections.push('coverage-threshold');
  sections.push('# Ignore specific language rules');
  sections.push('rust/edition-2024');
  sections.push('# Ignore all TypeScript rules');
  sections.push('typescript/*');
  sections.push('```');
  sections.push('');
  sections.push('<!-- RULEBOOK:END -->');
  sections.push('');

  return sections.join('\n');
}

export async function generateLanguageRules(language: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'languages');
  const templatePath = path.join(templatesDir, `${language.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  return `<!-- ${language.toUpperCase()}:START -->\n# ${language.charAt(0).toUpperCase() + language.slice(1)} Rules\n\nLanguage-specific rules for ${language}.\n<!-- ${language.toUpperCase()}:END -->\n`;
}

export async function generateFrameworkRules(framework: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'frameworks');
  const templatePath = path.join(templatesDir, `${framework.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  const title = framework.charAt(0).toUpperCase() + framework.slice(1);
  return `<!-- ${framework.toUpperCase()}:START -->
# ${title} Framework Rules

Framework-specific rules for ${title}.
<!-- ${framework.toUpperCase()}:END -->
`;
}

export async function generateModuleRules(module: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'modules');
  const templatePath = path.join(templatesDir, `${module.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  return `<!-- ${module.toUpperCase()}:START -->\n# ${module.charAt(0).toUpperCase() + module.slice(1)} Instructions\n\nModule-specific instructions for ${module}.\n<!-- ${module.toUpperCase()}:END -->\n`;
}

export async function generateGitRules(pushMode: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'git');
  const templatePath = path.join(templatesDir, 'GIT_WORKFLOW.md');

  let gitRules = '';

  if (await fileExists(templatePath)) {
    gitRules = await readFile(templatePath);
  } else {
    gitRules = `<!-- GIT:START -->\n# Git Workflow Rules\n\nGit workflow guidelines for this project.\n<!-- GIT:END -->\n`;
  }

  // Add push mode configuration
  const pushModeConfig = `\n**AI Assistant Git Push Mode**: ${pushMode.toUpperCase()}\n\n`;

  const pushModeInstructions = {
    manual: `**CRITICAL**: Never execute \`git push\` commands automatically.
Always provide push commands for manual execution by the user.

Example:
\`\`\`
✋ MANUAL ACTION REQUIRED:
Run these commands manually (SSH password may be required):
  git push origin main
  git push origin v1.0.0
\`\`\``,

    prompt: `**CRITICAL**: Always ask user permission before pushing.

Example:
\`\`\`
Ready to push changes. Execute these commands?
  git push origin main

[Y/n]:
\`\`\``,

    auto: `**INFO**: Automatic push enabled.
AI assistants may execute push commands automatically.

⚠️ Only use this mode if:
- SSH key has no password
- GitHub CLI is authenticated
- You trust the AI assistant completely`,
  };

  // Insert push mode config after <!-- GIT:START -->
  gitRules = gitRules.replace(
    '<!-- GIT:START -->',
    `<!-- GIT:START -->\n${pushModeConfig}${pushModeInstructions[pushMode as keyof typeof pushModeInstructions]}\n`
  );

  return gitRules;
}

export async function generateFullAgents(config: ProjectConfig): Promise<string> {
  const sections: string[] = [];

  // Add Rulebook section
  sections.push(await generateAgentsContent(config));
  sections.push('');

  // Add language-specific rules
  for (const language of config.languages) {
    const langRules = await generateLanguageRules(language);
    sections.push(langRules);
    sections.push('');
  }

  // Add framework-specific rules
  for (const framework of config.frameworks || []) {
    const frameworkRules = await generateFrameworkRules(framework);
    sections.push(frameworkRules);
    sections.push('');
  }

  if (!config.minimal) {
    // Add AGENT_AUTOMATION module when not in minimal mode
    const agentAutomation = await generateModuleRules('agent_automation');
    sections.push(agentAutomation);
    sections.push('');
  }

  // Add module-specific rules
  for (const module of config.modules) {
    const moduleRules = await generateModuleRules(module);
    sections.push(moduleRules);
    sections.push('');
  }

  // Add Git workflow rules if enabled
  if (config.includeGitWorkflow) {
    const gitRules = await generateGitRules(config.gitPushMode || 'manual');
    sections.push(gitRules);
    sections.push('');
  }

  return sections.join('\n').trim() + '\n';
}
