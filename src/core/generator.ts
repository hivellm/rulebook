import path from 'path';
import { readFile, fileExists, writeFile, ensureDir } from '../utils/file-system.js';
import type { ProjectConfig } from '../types.js';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Resolve templates directory (handles both dev and production)
function getTemplatesDir(): string {
  // In production (dist/), templates are at package root
  // In development (src/), templates are at package root
  // Both resolve to same location
  return path.join(__dirname, '..', '..', 'templates');
}

// Helper to read core template files (AGENT_AUTOMATION, DOCUMENTATION_RULES, QUALITY_ENFORCEMENT, RULEBOOK)
async function generateCoreRules(name: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'core');
  const templatePath = path.join(templatesDir, `${name.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  return `<!-- ${name.toUpperCase()}:START -->\n# ${name.charAt(0).toUpperCase() + name.slice(1)} Rules\n\nCore rules for ${name}.\n<!-- ${name.toUpperCase()}:END -->\n`;
}

export async function generateAgentsContent(config: ProjectConfig): Promise<string> {
  const sections: string[] = [];

  // Header comment
  sections.push('<!-- RULEBOOK:START -->');
  sections.push('# Project Rules');
  sections.push('');
  sections.push('Generated by @hivellm/rulebook');
  sections.push(`Generated at: ${new Date().toISOString()}`);
  sections.push('');

  const rulebookDir = config.rulebookDir || 'rulebook';

  // RULEBOOK.md has HIGHEST PRECEDENCE - must be first and most prominent
  sections.push('## ‚ö†Ô∏è CRITICAL: Task Management Rules (HIGHEST PRECEDENCE)');
  sections.push('');
  sections.push('**MANDATORY**: All task creation MUST follow Rulebook task management system.');
  sections.push('');
  sections.push(
    `**üìã ALWAYS reference \`/${rulebookDir}/RULEBOOK.md\` FIRST before creating any tasks or when "openspec" is mentioned.**`
  );
  sections.push('');
  sections.push('**Rules from RULEBOOK.md take precedence over all other rules in this file.**');
  sections.push('');
  sections.push('**Key Requirements:**');
  sections.push('- ‚úÖ Context7 MCP is REQUIRED for task creation');
  sections.push('- ‚úÖ All tasks MUST follow OpenSpec-compatible format');
  sections.push('- ‚úÖ Use `rulebook task create` instead of OpenSpec commands');
  sections.push('- ‚úÖ Always validate task format before committing');
  sections.push('- ‚ùå NEVER create tasks without checking RULEBOOK.md format requirements');
  sections.push('- ‚ùå NEVER use OpenSpec commands - use Rulebook task system instead');
  sections.push('');
  sections.push('### ‚ö†Ô∏è CRITICAL: Task File Structure Rules');
  sections.push('');
  sections.push(
    '**MANDATORY**: When creating or updating tasks, you MUST follow the correct file structure:'
  );
  sections.push('');
  sections.push('**‚úÖ CORRECT File Structure:**');
  sections.push('- `proposal.md` - **Why** and **What Changes** (detailed explanations go here)');
  sections.push('- `tasks.md` - **ONLY checklist items** (simple `- [ ]` or `- [x]` format)');
  sections.push(
    '- `specs/<module>/spec.md` - **Technical specifications** (SHALL/MUST requirements)'
  );
  sections.push('- `design.md` - **Technical design decisions** (optional, for complex features)');
  sections.push('');
  sections.push('**‚ùå FORBIDDEN Practices:**');
  sections.push('- ‚ùå **NEVER** add long explanations or specifications in `tasks.md`');
  sections.push('- ‚ùå **NEVER** put technical details in `tasks.md` (use `specs/` instead)');
  sections.push('- ‚ùå **NEVER** create `README.md` or `README` files in task directories');
  sections.push('- ‚ùå **NEVER** create `PROCESS.md` or `PROCESS` files in task directories');
  sections.push('- ‚ùå **NEVER** create any file not listed in the correct structure above');
  sections.push('');
  sections.push('**What Goes Where:**');
  sections.push('');
  sections.push('1. **`proposal.md`** - Use for:');
  sections.push('   - Detailed "Why" explanations (minimum 20 characters)');
  sections.push('   - "What Changes" descriptions');
  sections.push('   - Impact analysis');
  sections.push('   - Business/technical rationale');
  sections.push('');
  sections.push('2. **`tasks.md`** - Use ONLY for:');
  sections.push('   - Simple checklist items: `- [ ] Task description`');
  sections.push('   - Status updates: `- [x] Completed task`');
  sections.push('   - Brief comments: `<!-- tested, coverage: 95% -->`');
  sections.push('   - **DO NOT** add long explanations, specifications, or technical details here');
  sections.push('');
  sections.push('3. **`specs/<module>/spec.md`** - Use for:');
  sections.push('   - Technical specifications with SHALL/MUST requirements');
  sections.push('   - Scenario definitions (Given/When/Then)');
  sections.push('   - Delta operations (ADDED/MODIFIED/REMOVED)');
  sections.push('   - All detailed technical requirements');
  sections.push('');
  sections.push('4. **`design.md`** - Use for (optional):');
  sections.push('   - Architecture decisions');
  sections.push('   - Technical design rationale');
  sections.push('   - Complex implementation details');
  sections.push('');
  sections.push('**Example of WRONG usage:**');
  sections.push('```markdown');
  sections.push('# tasks.md (WRONG - too much detail)');
  sections.push('');
  sections.push('## Implementation');
  sections.push('- [ ] Create authentication system');
  sections.push('  The system SHALL implement JWT-based authentication...');
  sections.push('  Users MUST be able to login with email and password...');
  sections.push('  The system MUST validate tokens...');
  sections.push('```');
  sections.push('');
  sections.push('**Example of CORRECT usage:**');
  sections.push('```markdown');
  sections.push('# tasks.md (CORRECT - simple checklist)');
  sections.push('');
  sections.push('## 1. Implementation Phase');
  sections.push('- [ ] 1.1 Create authentication module');
  sections.push('- [ ] 1.2 Add JWT token generation');
  sections.push('- [ ] 1.3 Implement password validation');
  sections.push('');
  sections.push('# specs/auth/spec.md (CORRECT - specifications here)');
  sections.push('');
  sections.push('## ADDED Requirements');
  sections.push('');
  sections.push('### Requirement: Authentication System');
  sections.push('The system SHALL implement JWT-based authentication.');
  sections.push('');
  sections.push('#### Scenario: User Login');
  sections.push('Given a user with valid credentials');
  sections.push('When the user submits login form');
  sections.push('Then the system MUST return a JWT token');
  sections.push('```');
  sections.push('');
  sections.push('**Remember:**');
  sections.push('- ‚úÖ `tasks.md` = Simple checklist only');
  sections.push('- ‚úÖ `proposal.md` = Why and what changes');
  sections.push('- ‚úÖ `specs/` = Technical specifications');
  sections.push('- ‚ùå No README, PROCESS, or other files');
  sections.push('');
  sections.push(
    `**For complete task management guidelines, see: \`/${rulebookDir}/RULEBOOK.md\`**`
  );
  sections.push('');
  sections.push('---');
  sections.push('');

  // Core rules summary (detailed rules in /rulebook/)
  sections.push('## Core Rules');
  sections.push('');
  sections.push('This project uses @hivellm/rulebook standards.');
  sections.push('');
  sections.push('**CRITICAL RULES:**');
  sections.push(
    '1. **ALWAYS check `RULEBOOK.md` first** when creating tasks or if "openspec" is mentioned'
  );
  sections.push(`2. Write tests first (${config.coverageThreshold}%+ coverage required)`);
  sections.push('3. Run quality checks before committing:');
  sections.push('   - Type check / Compiler check');
  sections.push('   - Linter (no warnings allowed)');
  sections.push('   - All tests (100% pass rate)');
  sections.push('   - Coverage check');
  sections.push('4. Update docs/ when implementing features');
  sections.push('5. Follow strict documentation structure');
  sections.push(
    '6. **NEVER run destructive deletions (`rm -rf`) in this repository; when adding submodules always use `git submodule add`.**'
  );
  sections.push('7. **Temporary files and scripts**:');
  sections.push('   - ‚úÖ ALL scripts MUST be created in `/scripts` directory');
  sections.push('   - ‚úÖ ALL temporary files (test, log, debug) MUST be in `/scripts`');
  sections.push('   - ‚úÖ ALL temporary files MUST be removed immediately after use (MANDATORY)');
  sections.push('   - ‚ùå NEVER create temporary files in project root or outside `/scripts`');
  sections.push('   - ‚ùå NEVER leave temporary files after use - clean up before committing');
  sections.push('');
  sections.push('## Detailed Rules');
  sections.push('');
  sections.push(`For comprehensive rules, see the corresponding files in \`/${rulebookDir}/\`:`);
  sections.push('');

  // RULEBOOK.md is always first in the list (highest precedence)
  sections.push(
    `- \`/${rulebookDir}/RULEBOOK.md\` - **Task management rules (HIGHEST PRECEDENCE)**`
  );

  // Only reference QUALITY_ENFORCEMENT if not in light mode
  if (!config.lightMode) {
    sections.push(`- \`/${rulebookDir}/QUALITY_ENFORCEMENT.md\` - Quality enforcement rules`);
  }

  // Only reference GIT if enabled
  if (config.includeGitWorkflow) {
    sections.push(`- \`/${rulebookDir}/GIT.md\` - Git workflow rules`);
  }

  sections.push('');
  sections.push(`Language-specific rules are in \`/${rulebookDir}/\`.`);
  sections.push(`Module-specific patterns are in \`/${rulebookDir}/\`.`);
  sections.push('');
  sections.push('When in doubt, ask to review @AGENTS.md first.');
  sections.push('');
  sections.push('<!-- RULEBOOK:END -->');

  return sections.join('\n');
}

export async function generateLanguageRules(language: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'languages');
  const templatePath = path.join(templatesDir, `${language.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  return `<!-- ${language.toUpperCase()}:START -->\n# ${language.charAt(0).toUpperCase() + language.slice(1)} Rules\n\nLanguage-specific rules for ${language}.\n<!-- ${language.toUpperCase()}:END -->\n`;
}

export async function generateFrameworkRules(framework: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'frameworks');
  const templatePath = path.join(templatesDir, `${framework.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  const title = framework.charAt(0).toUpperCase() + framework.slice(1);
  return `<!-- ${framework.toUpperCase()}:START -->
# ${title} Framework Rules

Framework-specific rules for ${title}.
<!-- ${framework.toUpperCase()}:END -->
`;
}

export async function generateModuleRules(module: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'modules');
  const templatePath = path.join(templatesDir, `${module.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  return `<!-- ${module.toUpperCase()}:START -->\n# ${module.charAt(0).toUpperCase() + module.slice(1)} Instructions\n\nModule-specific instructions for ${module}.\n<!-- ${module.toUpperCase()}:END -->\n`;
}

export async function generateServiceRules(service: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'services');
  // Convert service name to template filename (e.g., 'azure_blob' -> 'AZURE_BLOB.md')
  const serviceName = service.toUpperCase().replace(/-/g, '_');
  const templatePath = path.join(templatesDir, `${serviceName}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  const serviceTitle = service
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');

  return `<!-- ${serviceName}:START -->\n# ${serviceTitle} Instructions\n\nService-specific instructions for ${serviceTitle}.\n<!-- ${serviceName}:END -->\n`;
}

export async function generateGitRules(pushMode: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'git');
  const templatePath = path.join(templatesDir, 'GIT_WORKFLOW.md');

  let gitRules = '';

  if (await fileExists(templatePath)) {
    gitRules = await readFile(templatePath);
  } else {
    gitRules = `<!-- GIT:START -->\n# Git Workflow Rules\n\nGit workflow guidelines for this project.\n<!-- GIT:END -->\n`;
  }

  // Add push mode configuration
  const pushModeConfig = `\n**AI Assistant Git Push Mode**: ${pushMode.toUpperCase()}\n\n`;

  const pushModeInstructions = {
    manual: `**CRITICAL**: Never execute \`git push\` commands automatically.
Always provide push commands for manual execution by the user.

Example:
\`\`\`
‚úã MANUAL ACTION REQUIRED:
Run these commands manually (SSH password may be required):
  git push origin main
  git push origin v1.0.0
\`\`\``,

    prompt: `**CRITICAL**: Always ask user permission before pushing.

Example:
\`\`\`
Ready to push changes. Execute these commands?
  git push origin main

[Y/n]:
\`\`\``,

    auto: `**INFO**: Automatic push enabled.
AI assistants may execute push commands automatically.

‚ö†Ô∏è Only use this mode if:
- SSH key has no password
- GitHub CLI is authenticated
- You trust the AI assistant completely`,
  };

  // Insert push mode config after <!-- GIT:START -->
  gitRules = gitRules.replace(
    '<!-- GIT:START -->',
    `<!-- GIT:START -->\n${pushModeConfig}${pushModeInstructions[pushMode as keyof typeof pushModeInstructions]}\n`
  );

  return gitRules;
}

/**
 * Write modular directive file to /rulebook/ directory
 * Adds header and footer comments for consistency
 */
async function writeModularFile(
  projectRoot: string,
  fileName: string,
  content: string,
  rulebookDir: string = 'rulebook'
): Promise<void> {
  const rulebookPath = path.join(projectRoot, rulebookDir);
  await ensureDir(rulebookPath);
  const filePath = path.join(rulebookPath, `${fileName}.md`);

  // Add header comment if not already present
  const headerComment = `<!-- ${fileName}:START -->\n`;
  const footerComment = `\n<!-- ${fileName}:END -->`;

  let finalContent = content.trim();

  // Add header if not present
  if (!finalContent.startsWith(headerComment.trim())) {
    finalContent = headerComment + finalContent;
  }

  // Add footer if not present
  if (!finalContent.endsWith(footerComment.trim())) {
    finalContent = finalContent + footerComment;
  }

  await writeFile(filePath, finalContent);
}

/**
 * Generate reference section for AGENTS.md
 */
function generateReferenceSection(
  name: string,
  fileName: string,
  description: string,
  quickRef: string[],
  rulebookDir: string = 'rulebook'
): string {
  const sections: string[] = [];
  sections.push(`### ${name}`);
  sections.push('');
  sections.push(`For comprehensive ${description}, see \`/${rulebookDir}/${fileName}.md\``);
  sections.push('');
  sections.push('Quick reference:');
  for (const item of quickRef) {
    sections.push(`- ${item}`);
  }
  sections.push('');
  return sections.join('\n');
}

/**
 * Generate language reference for AGENTS.md
 */
function generateLanguageReference(language: string, rulebookDir: string = 'rulebook'): string {
  const languageName = language.charAt(0).toUpperCase() + language.slice(1);
  const quickRef = [
    'Type safety and strict mode',
    'Code quality standards',
    'Testing requirements (95%+ coverage)',
    'Package management',
    'Error handling patterns',
  ];
  return generateReferenceSection(
    `${languageName} Development Rules`,
    language.toUpperCase(),
    `${languageName}-specific guidelines`,
    quickRef,
    rulebookDir
  );
}

/**
 * Generate framework reference for AGENTS.md
 */
function generateFrameworkReference(framework: string, rulebookDir: string = 'rulebook'): string {
  const frameworkName = framework.charAt(0).toUpperCase() + framework.slice(1);
  const quickRef = [
    'Framework-specific patterns',
    'Component structure',
    'Best practices',
    'Testing conventions',
  ];
  return generateReferenceSection(
    `${frameworkName} Framework Rules`,
    framework.toUpperCase(),
    `${frameworkName}-specific guidelines`,
    quickRef,
    rulebookDir
  );
}

/**
 * Generate module reference for AGENTS.md
 */
function generateModuleReference(module: string, rulebookDir: string = 'rulebook'): string {
  const moduleName = module.charAt(0).toUpperCase() + module.slice(1).replace(/_/g, ' ');
  const quickRef = ['Module-specific instructions', 'Usage guidelines', 'Integration patterns'];
  return generateReferenceSection(
    `${moduleName} Instructions`,
    module.toUpperCase(),
    `${moduleName}-specific instructions`,
    quickRef,
    rulebookDir
  );
}

/**
 * Generate service reference for AGENTS.md
 */
function generateServiceReference(service: string, rulebookDir: string = 'rulebook'): string {
  const serviceName = service
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
  const serviceId = service.toUpperCase().replace(/-/g, '_');
  const quickRef = ['Connection setup', 'Basic operations', 'Best practices', 'Configuration'];
  return generateReferenceSection(
    `${serviceName} Instructions`,
    serviceId,
    `${serviceName}-specific instructions`,
    quickRef,
    rulebookDir
  );
}

/**
 * Load project configuration from .rulebook file
 */
async function loadProjectConfigFromRulebook(
  projectRoot: string = process.cwd()
): Promise<Partial<ProjectConfig>> {
  const { createConfigManager } = await import('./config-manager.js');
  const configManager = createConfigManager(projectRoot);

  try {
    const rulebookConfig = await configManager.loadConfig();

    // Map RulebookConfig to ProjectConfig
    const projectConfig: Partial<ProjectConfig> = {
      languages: rulebookConfig.languages || [],
      frameworks: rulebookConfig.frameworks || [],
      modules: rulebookConfig.modules || [],
      services: rulebookConfig.services || [],
      modular: rulebookConfig.modular !== false, // Default to true
      rulebookDir: rulebookConfig.rulebookDir || 'rulebook',
    };

    return projectConfig;
  } catch {
    // If .rulebook doesn't exist or can't be read, return empty config
    return {};
  }
}

/**
 * Generate modular AGENTS.md with references
 */
export async function generateModularAgents(
  config: ProjectConfig,
  projectRoot: string = process.cwd()
): Promise<string> {
  // Load saved configuration from .rulebook and merge with provided config
  const savedConfig = await loadProjectConfigFromRulebook(projectRoot);

  // Merge: saved config takes precedence for languages/frameworks/modules/services
  // provided config takes precedence for other settings (like rulebookDir when explicitly set)
  const mergedConfig: ProjectConfig = {
    ...config,
    languages: savedConfig.languages?.length ? savedConfig.languages : config.languages,
    frameworks: savedConfig.frameworks?.length ? savedConfig.frameworks : config.frameworks || [],
    modules: savedConfig.modules?.length ? savedConfig.modules : config.modules,
    services: savedConfig.services?.length ? savedConfig.services : config.services || [],
    modular: savedConfig.modular !== undefined ? savedConfig.modular : config.modular !== false,
    // rulebookDir: provided config takes precedence if explicitly set, otherwise use saved or default
    rulebookDir: config.rulebookDir || savedConfig.rulebookDir || 'rulebook',
  };

  const rulebookDir = mergedConfig.rulebookDir || 'rulebook';
  const sections: string[] = [];

  // Add Rulebook section (core rules stay embedded - simplified)
  sections.push(await generateAgentsContent(mergedConfig));
  sections.push('');

  // Write RULEBOOK.md to /rulebook/ (ALWAYS included - highest precedence)
  const rulebookContent = await generateCoreRules('RULEBOOK');
  await writeModularFile(projectRoot, 'RULEBOOK', rulebookContent.trim(), rulebookDir);

  // Write QUALITY_ENFORCEMENT to /rulebook/ (always included unless light mode)
  if (!mergedConfig.lightMode) {
    const enforcementContent = await generateCoreRules('QUALITY_ENFORCEMENT');
    await writeModularFile(
      projectRoot,
      'QUALITY_ENFORCEMENT',
      enforcementContent.trim(),
      rulebookDir
    );
  }

  // Write Git workflow rules to /rulebook/GIT.md
  if (mergedConfig.includeGitWorkflow) {
    const gitRules = await generateGitRules(mergedConfig.gitPushMode || 'manual');
    await writeModularFile(projectRoot, 'GIT', gitRules.trim(), rulebookDir);
  }

  // Write language files and add references
  if (mergedConfig.languages.length > 0) {
    sections.push('## Language-Specific Rules');
    sections.push('');
    sections.push(
      'The following languages are configured for this project. For detailed rules, see the corresponding files in `/rulebook/`:'
    );
    sections.push('');

    // Write all language files first
    for (const language of mergedConfig.languages) {
      const langRules = await generateLanguageRules(language);
      await writeModularFile(projectRoot, language.toUpperCase(), langRules, rulebookDir);
    }

    // Then add all references together
    for (const language of mergedConfig.languages) {
      sections.push(generateLanguageReference(language, rulebookDir));
    }

    sections.push(
      '**Usage**: When working with language-specific code, reference the corresponding `/rulebook/[LANGUAGE].md` file for detailed guidelines.'
    );
    sections.push('');
  }

  // Write framework files and add references
  if (mergedConfig.frameworks && mergedConfig.frameworks.length > 0) {
    sections.push('## Framework-Specific Rules');
    sections.push('');
    sections.push(
      'The following frameworks are configured for this project. For detailed rules, see the corresponding files in `/rulebook/`:'
    );
    sections.push('');

    // Write all framework files first
    for (const framework of mergedConfig.frameworks) {
      const frameworkRules = await generateFrameworkRules(framework);
      await writeModularFile(projectRoot, framework.toUpperCase(), frameworkRules, rulebookDir);
    }

    // Then add all references together
    for (const framework of mergedConfig.frameworks) {
      sections.push(generateFrameworkReference(framework, rulebookDir));
    }

    sections.push('');
    sections.push(
      '**Usage**: When working with framework-specific code, reference the corresponding `/rulebook/[FRAMEWORK].md` file for detailed guidelines.'
    );
    sections.push('');
  }

  // Write module files and add references
  // First, write AGENT_AUTOMATION if not minimal (core file, not module)
  if (!mergedConfig.minimal) {
    const agentAutomation = await generateCoreRules('AGENT_AUTOMATION');
    await writeModularFile(projectRoot, 'AGENT_AUTOMATION', agentAutomation, rulebookDir);
  }

  // Then handle all modules together
  const allModules: string[] = [];
  if (!mergedConfig.minimal) {
    allModules.push('agent_automation');
  }
  allModules.push(...mergedConfig.modules);

  if (allModules.length > 0) {
    sections.push('## Module-Specific Instructions');
    sections.push('');
    sections.push(
      'The following modules are configured for this project. For detailed instructions, see the corresponding files in `/rulebook/`:'
    );
    sections.push('');

    // Write all module files first (except AGENT_AUTOMATION which is already written)
    for (const module of mergedConfig.modules) {
      const moduleRules = await generateModuleRules(module);
      await writeModularFile(projectRoot, module.toUpperCase(), moduleRules, rulebookDir);
    }

    // Then add all references together
    if (!mergedConfig.minimal) {
      sections.push(generateModuleReference('agent_automation', rulebookDir));
    }
    for (const module of mergedConfig.modules) {
      sections.push(generateModuleReference(module, rulebookDir));
    }

    sections.push(
      '**Usage**: When working with module-specific features, reference the corresponding `/rulebook/[MODULE].md` file for detailed instructions.'
    );
    sections.push('');
  }

  // Write service files and add references
  if (mergedConfig.services && mergedConfig.services.length > 0) {
    sections.push('## Service-Specific Instructions');
    sections.push('');
    sections.push(
      'The following services are configured for this project. For detailed instructions, see the corresponding files in `/rulebook/`:'
    );
    sections.push('');

    // Write all service files first
    for (const service of mergedConfig.services) {
      const serviceRules = await generateServiceRules(service);
      const serviceId = service.toUpperCase().replace(/-/g, '_');
      await writeModularFile(projectRoot, serviceId, serviceRules, rulebookDir);
    }

    // Then add all references together
    for (const service of mergedConfig.services) {
      sections.push(generateServiceReference(service, rulebookDir));
    }

    sections.push(
      '**Usage**: When working with service-specific features, reference the corresponding `/rulebook/[SERVICE].md` file for detailed instructions.'
    );
    sections.push('');
  }

  // Add enabled skills section (v2.0)
  try {
    const { SkillsManager, getDefaultTemplatesPath } = await import('./skills-manager.js');
    const { createConfigManager } = await import('./config-manager.js');

    const configManager = createConfigManager(projectRoot);
    const rulebookConfig = await configManager.loadConfig();

    if (rulebookConfig.skills?.enabled && rulebookConfig.skills.enabled.length > 0) {
      const skillsManager = new SkillsManager(getDefaultTemplatesPath(), projectRoot);
      const enabledSkills = await skillsManager.getEnabledSkills(rulebookConfig);

      // Add capabilities summary
      if (enabledSkills.length > 0) {
        sections.push('## Project Capabilities');
        sections.push('');
        sections.push('This project has the following AI-assisted capabilities enabled:');
        sections.push('');

        // Group skills by category for summary
        const categorySummary = new Map<string, string[]>();
        for (const skill of enabledSkills) {
          const category = skill.category;
          if (!categorySummary.has(category)) {
            categorySummary.set(category, []);
          }
          categorySummary.get(category)?.push(skill.metadata.name);
        }

        for (const [category, skills] of categorySummary.entries()) {
          const categoryLabel = category.charAt(0).toUpperCase() + category.slice(1);
          sections.push(`- **${categoryLabel}**: ${skills.join(', ')}`);
        }

        sections.push('');
        sections.push('Use `rulebook skill list` to see all available skills.');
        sections.push('Use `rulebook skill add <skill-id>` to enable additional skills.');
        sections.push('');
      }

      // Add skills content (includes index and detailed rules)
      const skillsContent = await skillsManager.mergeSkillsContent(rulebookConfig);
      if (skillsContent) {
        sections.push(skillsContent);
      }
    }
  } catch {
    // Skills not configured or error loading - skip silently
  }

  return sections.join('\n').trim() + '\n';
}

/**
 * Generate full AGENTS.md (modular by default, legacy mode available)
 */
export async function generateFullAgents(
  config: ProjectConfig,
  projectRoot: string = process.cwd()
): Promise<string> {
  // Use modular generation by default (unless explicitly disabled)
  if (config.modular !== false) {
    return await generateModularAgents(config, projectRoot);
  }

  // Legacy mode: embed all templates
  const sections: string[] = [];

  // Add Rulebook section
  sections.push(await generateAgentsContent(config));
  sections.push('');

  // Add RULEBOOK.md rules (ALWAYS included - highest precedence)
  const rulebookContent = await generateCoreRules('RULEBOOK');
  sections.push(rulebookContent);
  sections.push('');

  // Add language-specific rules
  for (const language of config.languages) {
    const langRules = await generateLanguageRules(language);
    sections.push(langRules);
    sections.push('');
  }

  // Add framework-specific rules
  for (const framework of config.frameworks || []) {
    const frameworkRules = await generateFrameworkRules(framework);
    sections.push(frameworkRules);
    sections.push('');
  }

  if (!config.minimal) {
    // Add AGENT_AUTOMATION (core file, not module) when not in minimal mode
    const agentAutomation = await generateCoreRules('AGENT_AUTOMATION');
    sections.push(agentAutomation);
    sections.push('');
  }

  // Add module-specific rules
  for (const module of config.modules) {
    const moduleRules = await generateModuleRules(module);
    sections.push(moduleRules);
    sections.push('');
  }

  // Add service-specific rules
  if (config.services && config.services.length > 0) {
    for (const service of config.services) {
      const serviceRules = await generateServiceRules(service);
      sections.push(serviceRules);
      sections.push('');
    }
  }

  // Add Git workflow rules if enabled
  if (config.includeGitWorkflow) {
    const gitRules = await generateGitRules(config.gitPushMode || 'manual');
    sections.push(gitRules);
    sections.push('');
  }

  return sections.join('\n').trim() + '\n';
}
