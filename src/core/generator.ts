import path from 'path';
import { readFile, fileExists, writeFile, ensureDir } from '../utils/file-system.js';
import type { ProjectConfig } from '../types.js';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Resolve templates directory (handles both dev and production)
function getTemplatesDir(): string {
  // In production (dist/), templates are at package root
  // In development (src/), templates are at package root
  // Both resolve to same location
  return path.join(__dirname, '..', '..', 'templates');
}

export async function generateAgentsContent(config: ProjectConfig): Promise<string> {
  const sections: string[] = [];

  // Header comment
  sections.push('<!-- RULEBOOK:START -->');
  sections.push('# Project Rules');
  sections.push('');
  sections.push('Generated by @hivellm/rulebook');
  sections.push(`Generated at: ${new Date().toISOString()}`);
  sections.push('');

  // Inject Quality Enforcement Rules if not in light mode
  if (!config.lightMode) {
    const enforcementPath = path.join(getTemplatesDir(), 'modules', 'QUALITY_ENFORCEMENT.md');
    const enforcementContent = await readFile(enforcementPath);
    sections.push(enforcementContent.trim());
    sections.push('');
    sections.push('');
  }

  // Documentation Standards
  sections.push('## Documentation Standards');
  sections.push('');
  if (config.strictDocs) {
    sections.push('**CRITICAL**: Minimize Markdown files. Keep documentation organized.');
    sections.push('');
    sections.push('### Allowed Root-Level Documentation');
    sections.push('Only these files are allowed in the project root:');
    sections.push('- ✅ `README.md` - Project overview and quick start');
    sections.push('- ✅ `CHANGELOG.md` - Version history and release notes');
    sections.push('- ✅ `AGENTS.md` - This file (AI assistant instructions)');
    sections.push('- ✅ `LICENSE` - Project license');
    sections.push('- ✅ `CONTRIBUTING.md` - Contribution guidelines');
    sections.push('- ✅ `CODE_OF_CONDUCT.md` - Code of conduct');
    sections.push('- ✅ `SECURITY.md` - Security policy');
    sections.push('');
    sections.push('### All Other Documentation');
    sections.push('**ALL other documentation MUST go in `/docs` directory**:');
    sections.push('- `/docs/ARCHITECTURE.md` - System architecture');
    sections.push('- `/docs/DEVELOPMENT.md` - Development guide');
    sections.push('- `/docs/ROADMAP.md` - Project roadmap');
    sections.push('- `/docs/DAG.md` - Component dependencies (DAG)');
    sections.push('- `/docs/specs/` - Feature specifications');
    sections.push('- `/docs/sdks/` - SDK documentation');
    sections.push('- `/docs/protocols/` - Protocol specifications');
    sections.push('- `/docs/guides/` - Developer guides');
    sections.push('- `/docs/diagrams/` - Architecture diagrams');
    sections.push('- `/docs/benchmarks/` - Performance benchmarks');
    sections.push('- `/docs/versions/` - Version release reports');
    sections.push('');
  } else {
    sections.push('Documentation should be well-organized in the `/docs` directory.');
    sections.push('');
  }

  // Testing Requirements
  sections.push('## Testing Requirements');
  sections.push('');
  sections.push('**CRITICAL**: All features must have comprehensive tests.');
  sections.push('');
  sections.push(`- **Minimum Coverage**: ${config.coverageThreshold}%`);
  sections.push('- **Test Location**: `/tests` directory in project root');
  sections.push('- **Test Execution**: 100% of tests MUST pass before moving to next task');
  sections.push('- **Test First**: Write tests based on specifications before implementation');
  sections.push('');

  // Feature Development Workflow
  sections.push('## Feature Development Workflow');
  sections.push('');
  sections.push('**CRITICAL**: Follow this workflow for all feature development.');
  sections.push('');
  sections.push('1. **Check Specifications First**:');
  sections.push('   - Read `/docs/specs/` for feature specifications');
  sections.push('   - Review `/docs/ARCHITECTURE.md` for system design');
  sections.push('   - Check `/docs/ROADMAP.md` for implementation timeline');
  sections.push('   - Review `/docs/DAG.md` for component dependencies');
  sections.push('');
  sections.push('2. **Implement with Tests**:');
  sections.push('   - Write tests in `/tests` directory first');
  sections.push('   - Implement feature following specifications');
  sections.push('   - Ensure tests pass and meet coverage threshold');
  sections.push('');
  sections.push('3. **Quality Checks**:');
  sections.push('   - Run code formatter');
  sections.push('   - Run linter (must pass with no warnings)');
  sections.push('   - Run all tests (must be 100% passing)');
  sections.push('   - Verify coverage meets threshold');
  sections.push('');
  sections.push('4. **Update Documentation**:');
  sections.push('   - Update `/docs/ROADMAP.md` progress');
  sections.push('   - Update feature specs if implementation differs');
  sections.push('   - Document any deviations with justification');
  sections.push('');

  // Rules Ignore
  sections.push('## Rules Configuration');
  sections.push('');
  sections.push('Rules can be selectively disabled using `.rulesignore` file in project root.');
  sections.push('');
  sections.push('Example `.rulesignore`:');
  sections.push('```');
  sections.push('# Ignore coverage requirement');
  sections.push('coverage-threshold');
  sections.push('# Ignore specific language rules');
  sections.push('rust/edition-2024');
  sections.push('# Ignore all TypeScript rules');
  sections.push('typescript/*');
  sections.push('```');
  sections.push('');
  sections.push('<!-- RULEBOOK:END -->');
  sections.push('');

  return sections.join('\n');
}

export async function generateLanguageRules(language: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'languages');
  const templatePath = path.join(templatesDir, `${language.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  return `<!-- ${language.toUpperCase()}:START -->\n# ${language.charAt(0).toUpperCase() + language.slice(1)} Rules\n\nLanguage-specific rules for ${language}.\n<!-- ${language.toUpperCase()}:END -->\n`;
}

export async function generateFrameworkRules(framework: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'frameworks');
  const templatePath = path.join(templatesDir, `${framework.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  const title = framework.charAt(0).toUpperCase() + framework.slice(1);
  return `<!-- ${framework.toUpperCase()}:START -->
# ${title} Framework Rules

Framework-specific rules for ${title}.
<!-- ${framework.toUpperCase()}:END -->
`;
}

export async function generateModuleRules(module: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'modules');
  const templatePath = path.join(templatesDir, `${module.toUpperCase()}.md`);

  if (await fileExists(templatePath)) {
    return await readFile(templatePath);
  }

  return `<!-- ${module.toUpperCase()}:START -->\n# ${module.charAt(0).toUpperCase() + module.slice(1)} Instructions\n\nModule-specific instructions for ${module}.\n<!-- ${module.toUpperCase()}:END -->\n`;
}

export async function generateGitRules(pushMode: string): Promise<string> {
  const templatesDir = path.join(getTemplatesDir(), 'git');
  const templatePath = path.join(templatesDir, 'GIT_WORKFLOW.md');

  let gitRules = '';

  if (await fileExists(templatePath)) {
    gitRules = await readFile(templatePath);
  } else {
    gitRules = `<!-- GIT:START -->\n# Git Workflow Rules\n\nGit workflow guidelines for this project.\n<!-- GIT:END -->\n`;
  }

  // Add push mode configuration
  const pushModeConfig = `\n**AI Assistant Git Push Mode**: ${pushMode.toUpperCase()}\n\n`;

  const pushModeInstructions = {
    manual: `**CRITICAL**: Never execute \`git push\` commands automatically.
Always provide push commands for manual execution by the user.

Example:
\`\`\`
✋ MANUAL ACTION REQUIRED:
Run these commands manually (SSH password may be required):
  git push origin main
  git push origin v1.0.0
\`\`\``,

    prompt: `**CRITICAL**: Always ask user permission before pushing.

Example:
\`\`\`
Ready to push changes. Execute these commands?
  git push origin main

[Y/n]:
\`\`\``,

    auto: `**INFO**: Automatic push enabled.
AI assistants may execute push commands automatically.

⚠️ Only use this mode if:
- SSH key has no password
- GitHub CLI is authenticated
- You trust the AI assistant completely`,
  };

  // Insert push mode config after <!-- GIT:START -->
  gitRules = gitRules.replace(
    '<!-- GIT:START -->',
    `<!-- GIT:START -->\n${pushModeConfig}${pushModeInstructions[pushMode as keyof typeof pushModeInstructions]}\n`
  );

  return gitRules;
}

/**
 * Write modular directive file to /rulebook/ directory
 * Adds header and footer comments for consistency
 */
async function writeModularFile(
  projectRoot: string,
  fileName: string,
  content: string,
  rulebookDir: string = 'rulebook'
): Promise<void> {
  const rulebookPath = path.join(projectRoot, rulebookDir);
  await ensureDir(rulebookPath);
  const filePath = path.join(rulebookPath, `${fileName}.md`);

  // Add header comment if not already present
  const headerComment = `<!-- ${fileName}:START -->\n`;
  const footerComment = `\n<!-- ${fileName}:END -->`;

  let finalContent = content.trim();

  // Add header if not present
  if (!finalContent.startsWith(headerComment.trim())) {
    finalContent = headerComment + finalContent;
  }

  // Add footer if not present
  if (!finalContent.endsWith(footerComment.trim())) {
    finalContent = finalContent + footerComment;
  }

  await writeFile(filePath, finalContent);
}

/**
 * Generate reference section for AGENTS.md
 */
function generateReferenceSection(
  name: string,
  fileName: string,
  description: string,
  quickRef: string[],
  rulebookDir: string = 'rulebook'
): string {
  const sections: string[] = [];
  sections.push(`## ${name}`);
  sections.push('');
  sections.push(`For comprehensive ${description}, see \`/${rulebookDir}/${fileName}.md\``);
  sections.push('');
  sections.push('Quick reference:');
  for (const item of quickRef) {
    sections.push(`- ${item}`);
  }
  sections.push('');
  return sections.join('\n');
}

/**
 * Generate language reference for AGENTS.md
 */
function generateLanguageReference(language: string, rulebookDir: string = 'rulebook'): string {
  const languageName = language.charAt(0).toUpperCase() + language.slice(1);
  const quickRef = [
    'Type safety and strict mode',
    'Code quality standards',
    'Testing requirements (95%+ coverage)',
    'Package management',
    'Error handling patterns',
  ];
  return generateReferenceSection(
    `${languageName} Development Rules`,
    language.toUpperCase(),
    `${languageName}-specific guidelines`,
    quickRef,
    rulebookDir
  );
}

/**
 * Generate framework reference for AGENTS.md
 */
function generateFrameworkReference(framework: string, rulebookDir: string = 'rulebook'): string {
  const frameworkName = framework.charAt(0).toUpperCase() + framework.slice(1);
  const quickRef = [
    'Framework-specific patterns',
    'Component structure',
    'Best practices',
    'Testing conventions',
  ];
  return generateReferenceSection(
    `${frameworkName} Framework Rules`,
    framework.toUpperCase(),
    `${frameworkName}-specific guidelines`,
    quickRef,
    rulebookDir
  );
}

/**
 * Generate module reference for AGENTS.md
 */
function generateModuleReference(module: string, rulebookDir: string = 'rulebook'): string {
  const moduleName = module.charAt(0).toUpperCase() + module.slice(1).replace(/_/g, ' ');
  const quickRef = ['Module-specific instructions', 'Usage guidelines', 'Integration patterns'];
  return generateReferenceSection(
    `${moduleName} Instructions`,
    module.toUpperCase(),
    `${moduleName}-specific instructions`,
    quickRef,
    rulebookDir
  );
}

/**
 * Generate modular AGENTS.md with references
 */
export async function generateModularAgents(
  config: ProjectConfig,
  projectRoot: string = process.cwd()
): Promise<string> {
  const rulebookDir = config.rulebookDir || 'rulebook';
  const sections: string[] = [];

  // Add Rulebook section (core rules stay embedded)
  sections.push(await generateAgentsContent(config));
  sections.push('');

  // Write language files and add references
  if (config.languages.length > 0) {
    sections.push('## Language-Specific Rules');
    sections.push('');
    sections.push(
      'The following languages are configured for this project. For detailed rules, see the corresponding files in `/rulebook/`:'
    );
    sections.push('');
    for (const language of config.languages) {
      const langRules = await generateLanguageRules(language);
      await writeModularFile(projectRoot, language.toUpperCase(), langRules, rulebookDir);
      sections.push(generateLanguageReference(language, rulebookDir));
    }
    sections.push('');
    sections.push(
      '**Usage**: When working with language-specific code, reference the corresponding `/rulebook/[LANGUAGE].md` file for detailed guidelines.'
    );
    sections.push('');
  }

  // Write framework files and add references
  if (config.frameworks && config.frameworks.length > 0) {
    sections.push('## Framework-Specific Rules');
    sections.push('');
    sections.push(
      'The following frameworks are configured for this project. For detailed rules, see the corresponding files in `/rulebook/`:'
    );
    sections.push('');
    for (const framework of config.frameworks) {
      const frameworkRules = await generateFrameworkRules(framework);
      await writeModularFile(projectRoot, framework.toUpperCase(), frameworkRules, rulebookDir);
      sections.push(generateFrameworkReference(framework, rulebookDir));
    }
    sections.push('');
    sections.push(
      '**Usage**: When working with framework-specific code, reference the corresponding `/rulebook/[FRAMEWORK].md` file for detailed guidelines.'
    );
    sections.push('');
  }

  // Write module files and add references
  if (!config.minimal) {
    const agentAutomation = await generateModuleRules('agent_automation');
    await writeModularFile(projectRoot, 'AGENT_AUTOMATION', agentAutomation, rulebookDir);
    sections.push(generateModuleReference('agent_automation', rulebookDir));
  }

  if (config.modules.length > 0) {
    sections.push('## Module-Specific Instructions');
    sections.push('');
    sections.push(
      'The following modules are configured for this project. For detailed instructions, see the corresponding files in `/rulebook/`:'
    );
    sections.push('');
    for (const module of config.modules) {
      const moduleRules = await generateModuleRules(module);
      await writeModularFile(projectRoot, module.toUpperCase(), moduleRules, rulebookDir);
      sections.push(generateModuleReference(module, rulebookDir));
    }
    sections.push('');
    sections.push(
      '**Usage**: When working with module-specific features, reference the corresponding `/rulebook/[MODULE].md` file for detailed instructions.'
    );
    sections.push('');
  }

  // Git workflow rules (keep embedded in AGENTS.md for now)
  if (config.includeGitWorkflow) {
    const gitRules = await generateGitRules(config.gitPushMode || 'manual');
    sections.push(gitRules);
    sections.push('');
  }

  return sections.join('\n').trim() + '\n';
}

/**
 * Generate full AGENTS.md (modular by default, legacy mode available)
 */
export async function generateFullAgents(
  config: ProjectConfig,
  projectRoot: string = process.cwd()
): Promise<string> {
  // Use modular generation by default (unless explicitly disabled)
  if (config.modular !== false) {
    return await generateModularAgents(config, projectRoot);
  }

  // Legacy mode: embed all templates
  const sections: string[] = [];

  // Add Rulebook section
  sections.push(await generateAgentsContent(config));
  sections.push('');

  // Add language-specific rules
  for (const language of config.languages) {
    const langRules = await generateLanguageRules(language);
    sections.push(langRules);
    sections.push('');
  }

  // Add framework-specific rules
  for (const framework of config.frameworks || []) {
    const frameworkRules = await generateFrameworkRules(framework);
    sections.push(frameworkRules);
    sections.push('');
  }

  if (!config.minimal) {
    // Add AGENT_AUTOMATION module when not in minimal mode
    const agentAutomation = await generateModuleRules('agent_automation');
    sections.push(agentAutomation);
    sections.push('');
  }

  // Add module-specific rules
  for (const module of config.modules) {
    const moduleRules = await generateModuleRules(module);
    sections.push(moduleRules);
    sections.push('');
  }

  // Add Git workflow rules if enabled
  if (config.includeGitWorkflow) {
    const gitRules = await generateGitRules(config.gitPushMode || 'manual');
    sections.push(gitRules);
    sections.push('');
  }

  return sections.join('\n').trim() + '\n';
}
