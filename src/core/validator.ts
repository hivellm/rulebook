import path from 'path';
import { fileExists, readFile } from '../utils/file-system.js';

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
  score: number;
}

export interface ValidationError {
  type: 'error';
  category: string;
  message: string;
  file?: string;
}

export interface ValidationWarning {
  type: 'warning';
  category: string;
  message: string;
  file?: string;
}

export async function validateProject(cwd: string = process.cwd()): Promise<ValidationResult> {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  // Check for AGENTS.md
  await validateAgentsFile(cwd, errors, warnings);

  // Check documentation structure
  await validateDocumentation(cwd, errors, warnings);

  // Check for tests directory
  await validateTests(cwd, errors, warnings);

  // Check for .rulesignore if present
  await validateRulesIgnore(cwd, warnings, errors);

  // Calculate score (errors -10 points, warnings -5 points each)
  const score = Math.max(0, 100 - (errors.length * 10 + warnings.length * 5));

  return {
    valid: errors.length === 0,
    errors,
    warnings,
    score,
  };
}

async function validateAgentsFile(
  cwd: string,
  errors: ValidationError[],
  warnings: ValidationWarning[]
): Promise<void> {
  const agentsPath = path.join(cwd, 'AGENTS.md');

  if (!(await fileExists(agentsPath))) {
    errors.push({
      type: 'error',
      category: 'standards',
      message: 'AGENTS.md not found in project root',
      file: 'AGENTS.md',
    });
    return;
  }

  // Read and validate AGENTS.md content
  const content = await readFile(agentsPath);

  if (!content.includes('<!-- RULEBOOK:START -->')) {
    warnings.push({
      type: 'warning',
      category: 'standards',
      message: 'AGENTS.md missing RULEBOOK block (not generated by @hivellm/rulebook)',
      file: 'AGENTS.md',
    });
  }

  if (content.length < 100) {
    warnings.push({
      type: 'warning',
      category: 'standards',
      message: 'AGENTS.md seems incomplete (very short)',
      file: 'AGENTS.md',
    });
  }
}

async function validateDocumentation(
  cwd: string,
  _errors: ValidationError[],
  warnings: ValidationWarning[]
): Promise<void> {
  const docsDir = path.join(cwd, 'docs');

  if (!(await fileExists(docsDir))) {
    warnings.push({
      type: 'warning',
      category: 'documentation',
      message: '/docs directory not found (recommended for organization)',
    });
    return;
  }

  // Check for important docs
  const importantDocs = ['ROADMAP.md', 'ARCHITECTURE.md'];
  for (const doc of importantDocs) {
    const docPath = path.join(docsDir, doc);
    if (!(await fileExists(docPath))) {
      warnings.push({
        type: 'warning',
        category: 'documentation',
        message: `${doc} not found in /docs (recommended)`,
        file: `docs/${doc}`,
      });
    }
  }

  // Check for specs directory
  const specsDir = path.join(docsDir, 'specs');
  if (!(await fileExists(specsDir))) {
    warnings.push({
      type: 'warning',
      category: 'documentation',
      message: '/docs/specs directory not found (recommended for feature specifications)',
    });
  }
}

async function validateTests(
  cwd: string,
  errors: ValidationError[],
  _warnings: ValidationWarning[]
): Promise<void> {
  const testsDir = path.join(cwd, 'tests');
  const testDir = path.join(cwd, 'test');

  const hasTests = (await fileExists(testsDir)) || (await fileExists(testDir));

  if (!hasTests) {
    errors.push({
      type: 'error',
      category: 'testing',
      message: '/tests directory not found (required by rulebook standards)',
    });
  }
}

async function validateRulesIgnore(
  cwd: string,
  warnings: ValidationWarning[],
  _errors?: ValidationError[]
): Promise<void> {
  const rulesIgnorePath = path.join(cwd, '.rulesignore');

  if (await fileExists(rulesIgnorePath)) {
    const content = await readFile(rulesIgnorePath);
    const lines = content.split('\n').filter((l) => l.trim() && !l.startsWith('#'));

    if (lines.length > 10) {
      warnings.push({
        type: 'warning',
        category: 'configuration',
        message: `.rulesignore has ${lines.length} rules ignored (consider reducing)`,
        file: '.rulesignore',
      });
    }

    // Check for wildcard ignores
    if (lines.some((l) => l === '*' || l === '**/*')) {
      warnings.push({
        type: 'warning',
        category: 'configuration',
        message: '.rulesignore ignores all rules (defeats purpose)',
        file: '.rulesignore',
      });
    }
  }
}

export function formatValidationReport(result: ValidationResult): string {
  const lines: string[] = [];

  lines.push('# Validation Report');
  lines.push('');
  lines.push(`**Score**: ${result.score}/100`);
  lines.push(`**Status**: ${result.valid ? '✅ PASSED' : '❌ FAILED'}`);
  lines.push('');

  if (result.errors.length > 0) {
    lines.push('## Errors');
    lines.push('');
    for (const error of result.errors) {
      lines.push(`- ❌ **${error.category}**: ${error.message}`);
      if (error.file) {
        lines.push(`  File: ${error.file}`);
      }
    }
    lines.push('');
  }

  if (result.warnings.length > 0) {
    lines.push('## Warnings');
    lines.push('');
    for (const warning of result.warnings) {
      lines.push(`- ⚠️ **${warning.category}**: ${warning.message}`);
      if (warning.file) {
        lines.push(`  File: ${warning.file}`);
      }
    }
    lines.push('');
  }

  if (result.valid && result.warnings.length === 0) {
    lines.push('## Summary');
    lines.push('');
    lines.push('✅ All checks passed! Your project follows rulebook standards.');
  }

  return lines.join('\n');
}
