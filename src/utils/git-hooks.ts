import { access, mkdir, writeFile, unlink } from 'fs/promises';
import path from 'path';
import { LanguageDetection } from '../types.js';

export interface HookGenerationOptions {
  languages: LanguageDetection[];
  cwd: string;
}

export async function installGitHooks(options: HookGenerationOptions): Promise<void> {
  const { languages, cwd } = options;

  const gitDir = path.join(cwd, '.git');
  try {
    await access(gitDir);
  } catch {
    throw new Error('Git repository not initialized. Run "git init" before installing hooks.');
  }

  const hooksDir = path.join(gitDir, 'hooks');

  // Ensure hooks directory exists
  await mkdir(hooksDir, { recursive: true });

  // Generate and install pre-commit hook
  const preCommitContent = generatePreCommitHook(languages);
  const preCommitPath = path.join(hooksDir, 'pre-commit');
  await writeFile(preCommitPath, preCommitContent, { mode: 0o755 });

  // Generate and install pre-push hook
  const prePushContent = generatePrePushHook(languages);
  const prePushPath = path.join(hooksDir, 'pre-push');
  await writeFile(prePushPath, prePushContent, { mode: 0o755 });
}

function generatePreCommitHook(languages: LanguageDetection[]): string {
  const checks: string[] = [];
  
  for (const lang of languages) {
    switch (lang.language) {
      case 'typescript':
      case 'javascript':
        checks.push(`
# TypeScript/JavaScript checks
if [ -f "package.json" ]; then
  echo "üîç Running TypeScript/JavaScript checks..."
  
  # Type check
  if grep -q '"type-check"' package.json; then
    npm run type-check || exit 1
  fi
  
  # Lint
  if grep -q '"lint"' package.json; then
    npm run lint || exit 1
  fi
  
  # Tests
  if grep -q '"test"' package.json; then
    npm test || exit 1
  fi
fi`);
        break;
        
      case 'rust':
        checks.push(`
# Rust checks
if [ -f "Cargo.toml" ]; then
  echo "üîç Running Rust checks..."
  
  # Format check
  cargo fmt --all -- --check || exit 1
  
  # Clippy
  cargo clippy --all-targets --all-features -- -D warnings || exit 1
  
  # Tests
  cargo test --all-features || exit 1
fi`);
        break;
        
      case 'python':
        checks.push(`
# Python checks
if [ -f "pyproject.toml" ] || [ -f "setup.py" ] || [ -f "requirements.txt" ]; then
  echo "üîç Running Python checks..."
  
  # Format check
  if command -v black &> /dev/null; then
    black --check . || exit 1
  fi
  
  # Lint
  if command -v ruff &> /dev/null; then
    ruff check . || exit 1
  elif command -v flake8 &> /dev/null; then
    flake8 . || exit 1
  fi
  
  # Type check
  if command -v mypy &> /dev/null; then
    mypy . || exit 1
  fi
  
  # Tests
  if command -v pytest &> /dev/null; then
    pytest || exit 1
  fi
fi`);
        break;
        
      case 'go':
        checks.push(`
# Go checks
if [ -f "go.mod" ]; then
  echo "üîç Running Go checks..."
  
  # Format check
  if [ "$(gofmt -l . | wc -l)" -gt 0 ]; then
    echo "‚ùå Go files not formatted. Run: gofmt -w ."
    exit 1
  fi
  
  # Vet
  go vet ./... || exit 1
  
  # Tests
  go test ./... || exit 1
fi`);
        break;
        
      case 'java':
        checks.push(`
# Java checks
if [ -f "pom.xml" ]; then
  echo "üîç Running Maven checks..."
  mvn verify || exit 1
elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
  echo "üîç Running Gradle checks..."
  ./gradlew check || exit 1
fi`);
        break;
        
      case 'csharp':
        checks.push(`
# C# checks
if [ -f "*.csproj" ] || [ -f "*.sln" ]; then
  echo "üîç Running .NET checks..."
  dotnet format --verify-no-changes || exit 1
  dotnet test || exit 1
fi`);
        break;
    }
  }
  
  // Default fallback if no specific language detected
  if (checks.length === 0) {
    checks.push(`
# Generic checks
echo "üîç Running generic checks..."

# Try common test commands
if [ -f "package.json" ] && grep -q '"test"' package.json; then
  npm test || exit 1
elif [ -f "Makefile" ]; then
  make test || exit 1
fi`);
  }
  
  return `#!/bin/sh
# Generated by Rulebook - Pre-commit hook
# Runs quality checks before allowing commits

echo "üöÄ Running pre-commit checks..."
${checks.join('\n')}

echo "‚úÖ All pre-commit checks passed!"
exit 0
`;
}

function generatePrePushHook(languages: LanguageDetection[]): string {
  const checks: string[] = [];
  
  for (const lang of languages) {
    switch (lang.language) {
      case 'typescript':
      case 'javascript':
        checks.push(`
# TypeScript/JavaScript checks
if [ -f "package.json" ]; then
  echo "üîç Running TypeScript/JavaScript checks..."
  
  # Full test suite
  if grep -q '"test"' package.json; then
    npm test || exit 1
  fi
  
  # Build
  if grep -q '"build"' package.json; then
    npm run build || exit 1
  fi
fi`);
        break;
        
      case 'rust':
        checks.push(`
# Rust checks
if [ -f "Cargo.toml" ]; then
  echo "üîç Running Rust checks..."
  
  # Full test suite
  cargo test --all-features || exit 1
  
  # Build release
  cargo build --release || exit 1
fi`);
        break;
        
      case 'python':
        checks.push(`
# Python checks
if [ -f "pyproject.toml" ] || [ -f "setup.py" ] || [ -f "requirements.txt" ]; then
  echo "üîç Running Python checks..."
  
  # Full test suite
  if command -v pytest &> /dev/null; then
    pytest || exit 1
  fi
  
  # Build/package check
  if [ -f "setup.py" ]; then
    python setup.py check || exit 1
  fi
fi`);
        break;
        
      case 'go':
        checks.push(`
# Go checks
if [ -f "go.mod" ]; then
  echo "üîç Running Go checks..."
  
  # Full test suite
  go test ./... || exit 1
  
  # Build
  go build ./... || exit 1
fi`);
        break;
        
      case 'java':
        checks.push(`
# Java checks
if [ -f "pom.xml" ]; then
  echo "üîç Running Maven checks..."
  mvn clean package || exit 1
elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
  echo "üîç Running Gradle checks..."
  ./gradlew clean build || exit 1
fi`);
        break;
        
      case 'csharp':
        checks.push(`
# C# checks
if [ -f "*.csproj" ] || [ -f "*.sln" ]; then
  echo "üîç Running .NET checks..."
  dotnet build -c Release || exit 1
fi`);
        break;
    }
  }
  
  // Default fallback
  if (checks.length === 0) {
    checks.push(`
# Generic checks
echo "üîç Running generic checks..."

# Try common build commands
if [ -f "package.json" ] && grep -q '"build"' package.json; then
  npm run build || exit 1
elif [ -f "Makefile" ]; then
  make build || exit 1
fi`);
  }
  
  return `#!/bin/sh
# Generated by Rulebook - Pre-push hook
# Runs comprehensive checks before allowing push

echo "üöÄ Running pre-push checks..."
${checks.join('\n')}

echo "‚úÖ All pre-push checks passed!"
exit 0
`;
}

export async function uninstallGitHooks(cwd: string): Promise<void> {
  const hooksDir = path.join(cwd, '.git', 'hooks');
  
  try {
    await unlink(path.join(hooksDir, 'pre-commit'));
  } catch (error) {
    // Ignore if file doesn't exist
  }
  
  try {
    await unlink(path.join(hooksDir, 'pre-push'));
  } catch (error) {
    // Ignore if file doesn't exist
  }
}

